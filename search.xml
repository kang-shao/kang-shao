<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaAPI]]></title>
    <url>%2F2019%2F03%2F11%2FJavaAPI%2F</url>
    <content type="text"><![CDATA[API(Application Programming lnterface)指的是应用程序接口。JavaAPI指的就是JDK中提供的的各种功能的Java类。 String类和StringBuffer类在应用程序中经常会用到字符串，所谓字符串就是指一连串的字符，它是由许多单个字符连接而成，如多个英文字母所组成的一个英文单词。字符串中可以包含任意字符，这些字符必须包含在一对双引号””之内，例如”abc”。在Java中定义了String和StringBuffer二个类来封装字符串，并提供了一系列操作字符串的方法，它们都位于java.lang包中，因此不需要导包就可以直接使用。 String类的初始化在操作String类之前，首先需要对String类进行初始化，在Java中可以通过以下二种方式对String类进行初始化，具体如下： 使用字符串常量直接初始化一个String对象，具体代码如下。 String str1 = &quot;abc&quot;; 由于String类比较常用，所以提供了这种简洁的语法，用于创建并初始化String对象。 使用String的构造方法初始化字符串对象，String类构造方法如下： 上图列出了String类的三种构造方法，通过调用不同的参数的构造方法便可完成String类的初始化。 String类的常见操作String类的常用方法如下图所示: 字符串的基本操作 在程序中，需要对字符串进行一些基本操作，如获取字符串长度、获得指定位置的字符等。String类针对每一个操作都提供了对应的方法。具体如下图所示: 如图所示，String类提供的方法可以很方便地获取字符串长度，获取指定位置的字符以及指定字符和字符串的位置。 字符串的转换操作 程序开发中，经常需要对字符串进行转换操作，例如将字符串转换成数组的形式，将字符进行大小写转换等。 使用String类的toCharArray()方法将一个字符串转换为一个字符数组，静态方法valueOf()将一个int类型的整数转为字符串,toUpperCase()方法将字符串中的字符都转为大写。其中，valueOf()方法有很多重载的形式，float、double、char等其他基本类型的数据都可以通过该方法转为String字符串类型。 字符串的替换和去除空格操作 程序开发过程中，用户输入数据时经常会有一些错误和空格，这是可以使用String类的replace()和trim()方法，进行字符串的替换和去除空格操作。 replace()方法用于将字符串中所有与指定字符串匹配字符串的子串替换成另一个字符串，trim()方法用于去除字符串中的空格。需要注意的是该方法只能去除二端的空格，不能去除中间的空格。若想去除字符串中间的空格，则可以调用String类和replace()方法。 字符串的判断操作 操作字符串时，经常需要对字符串进行一些判断，如判断字符串是否以指定的字符串开始、结束，是否包含指定的字符串，字符串为空等。 上图中涉及到的方法都是用于判断字符串的，并且返回值均为boolean类型。其中，equals()方法比较重要，该方法将父类Object中equals()方法进行重写。 在程序中可以通过“==”和equals()二种方式对字符串进行比较，但这两种方式有明显的区别。equals()方法用于比较二个字符串中的字符是否相等，==方法用于比较二个字符串对象的地址是否相同。对于两个字符串对象，当他们的字符内容完全相同时，使用equals判断结果会为true，但使用==判断时，结果一定为false。 123456 String str1 = new String(&quot;abc&quot;);String str2 = new String(&quot;abc&quot;);//结果为false，因为str1和str2是二个对象System.out.println(str1==str2);//结果为true，因为str1和str2字符内容相同System.out.println(str1.equals(str2)); 字符串的截取和分隔 在String类中针对字符串的截取和分隔操作提供了二个方法。其中，substring()方法用于截取字符串的一部分，split()方法可以将字符串按照某个字符进行分隔。 调用了String类中重载的二个substring()方法。在调用substring()方法时，传入了参数4，因为字符串中的字符索引是从0开始的，所以会截取字符串中第5个以及以后的所有字符。第七行代码调用substring()方法时传入二个参数4和6，因为字符串在截取时，只包括开始索引，不包括结束索引，所以会截取第5个和第6个字符。split()方法的用法，该方法会根据指定的符号”,”将字符串分隔成3个部分，并存放到一个String类型的数组当中。 String字符串在获取某个字符时，会用到字符的索引。当访问字符串中的字符时，如果字符索引不存在，则会发生StringIndexOutOfBoundsException(字符串角标越界异常)。 StringBuffer类由于字符串是常量，因此一旦创建，其内容和长度是不可改变的。如果需要对一个字符串进行修改，则只能创建新的字符串。为了便于对字符串进行修改，在JDK中提供了一个StringBuffer类(也称字符串缓冲区)。StringBuffer类和String类最大的区别在于他的内容和长度都是可以改变的。StringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StringBuffer对象。 针对添加和删除字符的操作，StringBuffer类提供了一系列的方法，如下图所示: 实例如下图所示: StringBuffer类有很多方法,其中,append()和insert()方法是最常用的，并且这二个方法有很多重载形式，他们都用于添加字符。不同的是，append()方法始终将这些字符添加到缓冲区的末尾，而insert()方法则可以在指定位置添加字符。另外，delete()方法用于删除指定位置的字符，setCharAt()和replace()方法用于替换指定位置的字符。 StringBuffer类和String类有很多相似之处，初学者在使用时很容易混淆。如下对比二个类的不同： String类表示的字符串是常量，一旦创建后，内容和长度都是无法改变的。而StringBuffer表示字符容器，其内容和长度可以随时修改。在操作字符串时，如果该字符仅用于表示数据类型，则使用String类即可。但是如果需要对字符串中的字符进行增删操作，则使用StringBuffer类。 String类覆盖了Object类的equals()方法，而StringBuffer类没有覆盖Object类的equals()方法，具体如下: String类对象可以用操作符“+”进行连接，而StringBuffer类对象之间不能，具体如下: 1234567String s1 = new &quot;a&quot;;String s2 = new &quot;b&quot;;String s3 = s1 + s2; //合法System.out.println(s3); //打印输出abStringBuffer sb1 = new StringBuffer(&quot;abc&quot;);StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);StringBuffer sb3 =sb1 + sb2;//编译出错 System类与Running类System类System类定义了一些与系统相关的属性和方法，它所提供的属性和方法都是静态的，因此，想要引用这些属性和方法，直接使用System类调用即可。 System类的常用方法如下所示: getProperties()方法 System类的getProperties()方法用于获取当前系统的全部属性，该方法会返回一个Properties对象，其中封装了系统的所有属性。这些属性是以键值对形式存在的。如下是getProperties()方法的使用。 如上实现了获取当前系统属性的功能。首先通过System的getProperties()方法获取了系统属性的Properties集合，然后对Properties集合进行迭代，将所有系统属性的键以及对应的值打印出来。 currentTimeMillis() currentTimeMillis()方法返回一个long类型的值，该值表示当前时间与1970年1月1日0点0分0秒之间的时间差，单位是毫秒，通常也将该值称作时间戳。 具体使用方法如下: arraycopy(Object src,int srcPos,Object dest,int destPos,int length) arraycopy()方法用于将一个数组中的元素快速拷贝到另一个数组，其中参数的具体作用如下， src:表示源数组 dest:表示目标数组 srcPos:表示源数组中拷贝元素的起始位置。 destPos:表示拷贝到目标数组的起始位置。 length:表示拷贝元素的个数。 在进行数组复制时，目标数组必须有足够的空间来存放拷贝的元素，否则会发生角标越界异常。 如上图所示:创建二个数组fromArray和toArray,分别代表源数组和目标数组。当调用arraycopy()方法进行元素拷贝时，由于指定了从源数组中索引为2的元素开始拷贝，并且拷贝4个元素存放在目标数组中索引为3的位置，因此在打印目标数组的元素时，程序首先打印的是数组toArray的前3个元素201、202、203，然后打印的是从fromArray中的4个元素。 System类还有二个常见的方法，分别是gc()和exit(int status)方法。其中，gc()方法用来启动Java的垃圾回收器，并且对内存中的垃圾对象进行回收。exit(int status)方法用来终止当前正在运行的Java虚拟机，其中参数status用于表示当前发生的异常状态，通常指定为0，表示正常退出，否则表示异常终止。 Running类Running类用于表示虚拟机运行时的状态，它用于封装JVM虚拟机进程。每次使用Java命令启动虚拟机都对应一个Running实例，因此该类采用单例模式进行设计，对象不可以直接实例化。若想在程序中获得一个Running实例，只能通过以下方式。 1Runtime run = Runtime.getRuntime(); 由于Running类封装了虚拟机进程，因此在程序中通常会通过该类的实例对象来获取当前虚拟机的相关信息。 如上图所示:Running.getRunning();方法创建了一个Runtime的实例对象，并分别调用该对象的availableProcessors()方法、freeMemory()方法，将当前虚拟机的处理器个数、空闲内存数和最大可用内存数的信息打印出来。由于每台计算机的配置和性能不同，该文件的打印结果也可能不同。另外，空闲内存数和可用最大内存数都是以字节为单位计算的。 Running类中提供了一个exec()方法，该方法用于执行一个dos命令，从而实现与在命令行窗口中输入dos命令同样的效果。如下实例: 调用了Running对象的exec()方法，并将系统命令”notepad.exe”作为参数传递给方法。运行程序会在桌面上打开一个记事本。运行上图程序以后，会在Windows系统产生一个新的进程notepad.exe。 Running类的exec()方法返回一个Process对象，该对象表示操作系统的一个进程，通过该对象可以对产生的新进程进行管理，如关闭此进程只需要调用destroy()方法即可。 Math类与Random类Math类Math类时数学操作类，提供了一系列用于数学运算的静态方法，包括求绝对值、三角函数等。Math类中有二个静态变量PI和E，分别代表数学常量π和e。如下图Math的常用方法: round()方法用于对某个小数进行四舍五入，此方法会将小数点后面的数字全部忽略，返回一个int类型的数，而ceil()方法和floor()方法返回的都是double类型的数，这个数在数值上等于一个整数。 Random类在JDK的Java.util包中有一个Random类，它可以在指定的范围内随机产生数字。在Random类中提供了二个构造方法，具体如下图所示: 上图列举了Random类的二个构造方法，其中第一个构造方法是无参的，通过它创建的Random实例对象每次使用的种子都是随机的，因此每个对象所产生的随机数不同。如果希望创建多个Random实例化对象产生相同序列的随机数，则可以在创建对象时调用第2个构造方法，传入相同的种子即可。通过以下实例采用第一种构造方法来产生随机数，如下所示： 运行二次产生的随机数序列是不一样的。这是因为当创建Random的实例对象时，没有指定种子，系统会以当前时间戳作为种子，产生随机数。 当创建Random类的实例化对象时，如果指定了相同的种子，则每个实例对象产生的随机数具有相同的序列。 相对于Math的random类提供了更多的方法来生成各种伪随机数，不仅可以生成整数类型的随机数，还可以生成浮点类型的随机数。如下图列举了Random类中的常用方法。 其中，Random类的nextDouble()方法返回的是0.0和1.0之间double类型的值，nextFloat()方法返回的是0.0~1.0之间float类型的值，nextInt(int n)返回的是0(包括)和指定值n(不包括)之间的值。 调用Random类不同的方法分别产生不同类型的随机数。 包装类在Java中，很多类的方法都需要接收引用类型的对象，此时就无法将一个基本数据类型的值传入。为了解决这样的问题，JDK中提供了一系列的包装类，通过这些包装类可以将基本数据类型的值包装为引用数据类型的对象。在Java中，每种基本类型都有对应的包装类。 上图列举了8种基本数据类型及其对应的包装类。其中，除了Integer和Character类，其他包装类的名称和基本数据类型的名称一致，只是类名的第一个字母需要大写。 包装类和基本数据类型在进行转换时，引入了装箱和拆箱的概念。其中，装箱是指将基本数据类型的值转为引用数据类型，反之，拆箱是指将引用数据类型的对象转为基本数据类型。如下图以int类型的包装类Integer为例，学习一下装箱过程。 包装类Integer的装箱过程，在创建Integer对象时，将int类型的变量a作为参数传入，从而转为Integer类型。由于Object类是所有类的父类，因此在输出语句中，可以通过调用toString()方法将Integer的值以字符串的形式打印出来。此处的toString()是可以省略的。 Integer类除了具有Object类的所有方法外，还有一些特有的方法，如下图所示。 列举了Integer的常用方法，其中的intValue()方法可以将Integer类型的值转为int类型，这个方法可以用来进行拆箱操作。接下来通过一个案例来演示intValue()方法的使用，如下图所示: 上图演示了拆箱的过程，Integer对象通过调用intValue()方法，将Integer对象转为int类型，从而可以与int类型的变量a进行加法运算，最终将运算结果正确打印。 parseInt()方法在程序中很常用，它是一个静态方法，用于将一个字符串形成的数据转为int类型。接下来用一个案例演示parseInt()方法的使用，该案例实现了在屏幕上打印“*”矩形，如下图所示。 程序运行时从键盘输入了二个参数，其中，第一个参数作为矩形的宽度，第二个参数作为矩形的高度。由于传入的参数都是字符串类型，不能直接使用，因此，通过调用包装类Integer的parseInt()方法将字符串转为整数，从而实现了矩形的打印。 在使用包装类时，需要注意一下几点。 包装类都重写了Object类中的toString()方法，以字符串的形式返回被包装的基本数据类型的值。 除了Character外，包装类都有valueOf(String s)方法，可以根据String类型的参数创建包装类对象，但参数字符串s不能为null，而且字符串必须是可以解析为相应基本类型的数据，否则虽然编译通过，但运行时会报错。 12Integer i = Integer.valueOf(&quot;123&quot;); //合法Integer i = Integer.valueOf(&quot;12a&quot;); //不合法 处理Character外，包装类都有parseXxx(String s)的静态方法，将字符串转换为对应的基本类型的数据。参数s不能为null，而且同样必须是可以解析为相应基本数据类型的数据，否则虽然编译通过，但运行报错。 12int i = Integer.parseInt(&quot;123&quot;); //合法Integer in = Integer.parseInt(&quot;hello&quot;);//不合法 JDK5.0新特性—自动拆箱和装箱 在JDK5.0版本之前，数学运算表达式中操作数必须是基本类型的，并且运行结果也是基本类型，包装类和基本类型是不允许进行混合数学运算的，如果想运算，必须要通过拆箱将包装类对象转为基本数据类型的值才行。 1234int a = 1; //合法int b = a + 1; //合法Integer c = a + b; //不合法，编译出错b = a + (new Integer(1));//不合法，编译报错 在JDK5.0的版本中提供了自动拆箱和装箱技术，也就是可以自动进行基本数据类型和包装类对象之间的转换，具体如下: 12int num = 20;Integer number = num; //自动装箱 上面的代码就是自动装箱，相当于程序自动执行了语句“Integer number = new Integer(num);”。 12Integer number = new Integer(18);int number2 =number;//自动拆箱 上面的代码就是自动拆箱，相当于程序自动执行了语句“int number2=number.intValue();”。 正因为自动拆箱装箱的特性，在JDK5.0版本以后，基本类型和包装类型可以进行混合数学运算，也可以直接将二个Integer类型进行数学运算，具体示例如下。 123public static Integer add(Integer a,Integer b)&#123; return a+b;&#125; JDK7.0新特性–switch语句支持字符串类型在JDK7.0中，switch语句的表达式增加了对字符串类型的支持。由于字符串的操作在编程中使用频繁，这个新特性的出现为Java编程带来了便利。如下演示:switch语句中使用字符串进行匹配。 switch语句条件表达式的值为“Friday”,与case条件中的字符串“Friday”相匹配，因此打印出“星期五”。 本章小结记录一个子串在整串中出现的次数1234567891011121314151617181920212223242526package Project;public class StringTest &#123; public static void main(String[] args) &#123; String str = &quot;qwertyuioqwertyuiwertyu&quot;; //整串 String key = &quot;ert&quot;; //子串 int count = getKeyStringCount(str,key); System.out.println(&quot;count=&quot;+count); &#125; //获取子串在整串中出现的次数 private static int getKeyStringCount(String str, String key) &#123; //定义计数器，记录出现的次数 int count = 0; //如果整串中不包含子串，则直接返回count if(!str.contains(key))&#123; return count; &#125; //定义变量记录key出现的位置 int index=0; while((index=str.indexOf(key))!=-1)&#123; str = str.substring(index+key.length()); count++; &#125; return count; &#125;&#125; 字符串排序程序设计1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Project;import java.util.Arrays;public class WrapperTest &#123; private static final String SPACE_SEPARATOR = &quot; &quot;; public static void main(String[] args) &#123; String numStr = &quot;20 12 35 -5 -56 99&quot;; System.out.println(numStr); numStr = sortStringNumber(numStr); System.out.println(numStr.toString()); &#125; public static String sortStringNumber(String numStr) &#123; //将字符串变成字符串数组 String[] str_arr = stringToArray(numStr); //将字符串数组变成int数组 int[] num_arr = toIntArray(str_arr); //对int数组排序 mySortArray(num_arr); //将排序以后的int数组变成字符串 String temp = arrayToString(num_arr); return temp; &#125; public static String arrayToString(int[] num_arr) &#123; StringBuffer sb = new StringBuffer(); for (int x = 0; x &lt; num_arr.length; x++) &#123; if(x!=num_arr.length-1)&#123; sb.append(num_arr[x]+SPACE_SEPARATOR); &#125;else &#123; sb.append(num_arr[x]); &#125; &#125; return sb.toString(); &#125; public static void mySortArray(int[] num_arr) &#123; Arrays.sort(num_arr); &#125; public static int[] toIntArray(String[] str_arr) &#123; int[] arr = new int[str_arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = Integer.parseInt(str_arr[i]); &#125; return arr; &#125; public static String[] stringToArray(String numStr) &#123; String[] str_arr = numStr.split(SPACE_SEPARATOR); return str_arr; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象-下]]></title>
    <url>%2F2019%2F02%2F25%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[类的继承继承的概念在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。 在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。在程序中，如果想要声明一个类继承另一个类，需要使用extends关键字。 注意：public class XX 与你创建该类时所写的名字不符，不管你什么类,只要是Class,就只能有一个public class(公共类) 子类在继承父类的时候，会自动拥有父类所有的成员。 在类的继承中，需要注意一些问题，具体如下： 在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类。 123class A&#123;&#125;class B&#123;&#125;class C extends A,B&#123;&#125;//C类不可以直接同时继承A类和B类 多个类可以继承一个父类。 123class A&#123;&#125;class B extends A&#123;&#125;class C extends A&#123;&#125;//类B和类C都可以继承类A 在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类。 1234class A&#123;&#125;class B extends A&#123;&#125;//类B继承类A,类B是类A的子类class C extends B&#123;&#125;//类C继承类B,类C继承类B的子类，同时也是类A的子类 在Java中，子类和父类是一种相对概念，也就是说一个类是某个类的父类的同时，也可以是另一个类的父类。 重写父类方法在继承关系中，子类会自动继承父类中定义的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。需要注意的是，在子类中重写的方法需要和父类被重写的方法具有相同的方法名、参数列表以及返回值类型。 注意:子类重写父类方法时，不能使用比父类中被重写的方法更严格的访问权限，如：父类中的方法是public的，子类的方法就不能是private的。 super关键字当子类重写父类的方法以后，子类对象将无法访问父类被重写的方法。为了解决这个问题，Java中专门提供了一个super关键字用于访问父类成员。例如访问成员父类的成员变量、成员方法和构造方法。 使用super关键字访问父类的成员变量和成员方法，具体格式如下。 12super.成员变量super.成员方法([参数1,参数2,···]) 使用super关键字访问父类的构造方法。 1super([参数1,参数2····]) 实例化Dog对象时，一定会调用Dog类的构造方法。从运行结构可以看出，Dog类的构造方法被调用时，父类的构造方法也被调用了。需要注意，通过super调用父类构造方法的代码必须位于子类构造方法的第一行，并且只能出现一次。 子类在实例化时默认调用了父类无参的构造方法。在定义一个类时，如果没有特殊需求，尽量在类中定义一个无参的构造方法，避免被继承时出现错误。 final关键字final关键字可用于修饰类、变量和方法，它有“无法改变”或者“最终”的含义，因此被final修饰的类、变量和方法将具有以下特性。 final修饰的类不能被继承。 final修饰的方法不能被子类重写。 final修饰的变量(成员变量和局部变量)是常量，只能赋值一次。 final关键字修饰类Java中的类被final关键字修饰以后，该类将不可以被继承，也就是不能够派生子类。 final关键字修饰方法当一个类的方法被final关键字修饰以后，这个子类将不能重写该方法。正是由于final的这种特性，当父类中定义某个方法时，如果不希望被子类重写，就可以使用final关键字修饰该方法。 final关键字修饰变量Java中被修饰的变量，它只能被赋值一次，也就是说final修饰的变量一旦被赋值，其值不能改变。如果再次对变量进行赋值，则程序会在编译时报错。 使用final关键字修饰成员变量时，虚拟机不会对其进行初始化。因此使用final修饰成员变量时，需要在定义变量的同时赋予一个初值。 抽象类和接口抽象类当定义一个类时，常常需要定义一些方法来描述该类的行为特征，但有时这些方法的实现方式是无法确定的。例如:,前面在定义Animal类时，shout()方法用于表示动物的叫声，但是针对不同的动物，叫声也是不同的，因此在shout()方法中无法确定描述动物的叫声。 针对上面描述的情况，Java允许在定义方法时不写方法体。不包含方法体的方法为抽象方法，抽象方法必须使用abstract关键字来修饰。 1abstract void shout();//定义抽象方法shout() 当一个类中包含了抽象方法，该类必须使用abstract关键字来修饰，使用abstract关键字修饰的类为抽象类。 12345//定义抽象类Animalabstract class Animal&#123; //定义抽象方法shout() abstract int shout();&#125; 在定义抽象类需要注意，包含抽象方法的类必须声明为抽象类，但抽象类可以不包含任何抽象方法，只需要使用abstract关键字来修饰即可。另外，抽象类是不可以被实例化的，因为抽象类中可能包含抽象方法，抽象方法是没有方法体的，不可以被调用。如果想要调用抽象类中定义的方法，则需要创建一个子类，在子类中将抽象类中的抽象方法进行实现。 子类实现了父类的抽象方法后,可以进行实例化，并通过实例化对象调用方法。 接口如果一个抽象类中的所有方法都是抽象的，则可以将这个类用另一种方式来定义，即接口。接口是由常量和抽象方法组成的特殊类，是对抽象类的进一步抽象。 在定义接口时，需要使用interface关键字来声明，其语法格式如下： 1234[public] interface 接口名 []&#123; [public] [static] [final] 数据类型 常量名 = 常量值; [public] [abstract] 返回值 抽象方法名(参数列表);&#125; 在上面的语法中，一个接口可以有多个父接口，它们之间用逗号隔开。Java使用接口的目的是为了克服单继承的限制，因为一个类只能有一个父类，而一个类可以实现多个接口。接口中的变量默认使用”public static final”来修饰，即全局常量；接口中定义的方法默认使用“public abstract” 来修饰,即抽象方法。如果接口声明为public，则接口中变量和方法全部为public。 由于接口中方法都是抽象方法，因此不能通过实例化对象的方式来调用接口中的方法。此时需要定义一个类，并使用implements关键字实现接口中的所有方法。一个类可以在继承另一个类的同时实现多个接口，这些接口在implements子句中要使用英文逗号(,)隔开。接口的实现类声明格式如下。 1[&lt;修饰符&gt;] class &lt;类名&gt; [extends&lt;超类名&gt;] [implements &lt;接口1&gt;,&lt;接口2&gt;,···] 从结果中可以看出，类Dog在实现了Animal接口后是可以被实例化的，并且实例化后就可以调用Dog类中的方法。需要注意的是，一个类实现一个一个接口，必须给出接口中所有方法的实现，如果不能实现某方法，也必须写出一个空方法。 在程序中，还可以定义一个接口使用extends关键字去继承另一个接口。 接口中的方法都是抽象的，不能实例化对象。 接口中的属性只能是常量。 当一个类实现接口时，如果这个类是抽象类，则实现接口中的部分方法即可，否则需要实现接口中的所有方法。 一个类通过implements关键字实现接口时，可以实现多个接口，被实现的多个接口之间用逗号隔开，具体如下: 123456789interface Run&#123; 程序代码····&#125;interface Fly&#123; 程序代码····&#125;class Bird implements Run,Fly&#123; 程序代码····&#125; 一个接口可以通过extends关键字继承多个接口，接口之间用逗号隔开，具体如下。 123456789interface Running&#123; 程序代码····&#125;interface Flying&#123; 程序代码···&#125;interface Eating extends Running,Flying&#123; 程序代码····&#125; 一个类在继承另一个类的同时还可以实现接口，此时，extends关键字必须位于implements关键字之前，具体实例如下: 123class Dog extends Canidae implements Animal&#123; //先继承，在实现 程序代码····&#125; 多态多态概述在设计一个方法时，通常希望该方法具备一定的通用性。在同一个方法中，这种由于参数类型不同而导致执行效果各异的现象就是多态。继承是多态得以实现的基础。 在Java中，为了实现多态，允许使用一个父类类型的变量来引用一个子类类型的对象，根据被引用子类对象特征的不同，得到不同的运行结果。代码如下: 多态不仅解决了方法同名的问题，而且还使程序变得更加灵活，从而有效地提高了程序的可扩展性和可维护性。 对象的类型转换在多态的学习中，涉及到将子类对象当作父类类型使用的情况，此种情况在Java的语言环境称为“向上转型”。 12Animal an1 = new Cat();//将Cat对象当作Animal类型来使用Animal an2 = new Dog();//将Dog对象当作Animal类型来使用 将子类对象当作父类使用时不需要任何显示地声明，需要注意的是，此时不能通过父类变量去调用子类中特有方法。 通过运行结果可以看出，将传入的对象由Animal类型转为Cat类型后，程序可以成功调用shout()和sleep()方法，这种将父类型当作子类型使用的情况，在Java的语言环境中被称为“向下转型”。 需要注意的是，在进行类型转换时也可能出现错误。 针对这种情况，Java提供了一个关键字instanceof,它可以判断一个对象是否为某个类(或接口)实例或者子类实例，语法格式如下。 1对象(或者对象引用变量) instanceof 类(或接口) Object类在JDK中提供了一个Object类，它是类层次结构的根类，每个类都直接或间接继承自该类，所有对象（包括数组）都实现了这个方法。Object类的常用方法如下图: 在代码中调用了Animal对象的toString()方法，虽然Animal类并没有定义这个方法，但程序并没有报错。这是因为Animal类默认继承自Object类,在Object类中定义了toString()方法，在该方法中输出了对象的基本信息，Object类中的toString()方法中的代码具体如下。 1getClass().getName()+&quot;@&quot;+Integer.toHexString(hashCode()); getClass().getName()代表返回对象所属类的类名，即Animal。 hashCode()代表返回该对象的哈希值。 Integer.toHexString(hashCode())代表将对象的哈希值用十六进制表示。 其中hashCode()是Object类中定义的一个方法，这个方法将对象的内存地址进行哈希运算，返回一个int联系的哈希值。 在实际开发中，通常希望对象的toString()方法返回的不仅仅是基本信息，而是一些特有信息。这是重写Object的toString()方法便可以实现。 匿名内部类在编写Java程序时，在类里面定义的类称之为内部类(Inner Class)内部类是外部类的一个成员。Java内部类可以分为成员内部类，方法内部类和匿名内部类等。 在前面多态的讲解中，如果方法参数被定义为一个参数类型，那么就需要定义一个类来实现接口，并根据该类进行对象实例化。除此之外，还可以使用匿名内部类来实现接口。所谓匿名内部类就是没有名字的内部类，表面上看起来它似乎有名字，实际上那并不是它的名字。当程序中使用匿名内部类时，在定义匿名内部类的地方往往直接创建该类的一个对象。 上图中，内部类Cat实现了Animal接口，在调用animalShout()方法时，将Cat类的实例对象作为参数传入到方法中，从而输出相应的结果。 匿名内部类的格式，具体如下： 123new 父类(参数列表) 或 父接口()&#123; //匿名内部类实现部分&#125; 上二张图结果一样，但在其代码中使用匿名内部类实现的Animal接口。接下来分二个步骤来编写匿名内部类。 在调用animalShout()方法时，在方法的参数位置写上new Animal(){},这相当于创建了一个实例对象，并将参数传给animalShout()方法。在new Animal()后面有一对大括号表示创建的对象为Animal的子类实例，该子类是匿名的。 1animalShout(new Animal()&#123;&#125;); 在大括号中编写匿名子类的实现代码 123456animalShout(new Animal() &#123; public void shout()&#123; System.out.println(&quot;喵喵···&quot;); &#125; &#125;); 匿名内部类是实现接口的一种简便写法，在程序中不一定非要使用匿名内部类。 异常什么是异常在程序运行的过程中，也会发生各种非正常状况，例如程序运行时磁盘空间不足、网络连接中断、被装载的类不存在等。针对这种情况，在Java语言中，引入了异常，以异常类的形式对这些非正常情况进行封装，通过异常处理机制对程序运行时发生的各种问题进行处理。 从结果可以看出，程序发生了算数异常(AnithmeticException)，这个异常是由于调用divide()方法时传入了参数0，而在divide()方法中，运算时出现了被0除的情况。在这个异常发生后，程序会立即结束，无法继续向下执行。 AnithmeticException异常只是Java异常类中的一种，在Java中还提供了大量的异常类，这些类都继承自java.lang.Throwable类。 如上可以看出，Throwable有二个直接子类Error和Exception。其中，Error代表程序中产生的错误，Exception代表程序中产生的异常。 Error类成为错误类，它表示Java运行时产生的系统内部错误或资源耗尽的错误，是比较严重的，紧靠修改程序本身是不能恢复执行的。使用Java命令运行一个不存在的类就会出现Error错误。 Exception类称为异常类，它表示程序本身可以处理的错误。在开发Java程序中进行的异常处理都是针对Exception类及其子类。在Exception类的众多子类中有一个特殊的RuntimeException类，该类及其子类用于表示运行时异常。除了此类，Exception类下所有其他的子类都用于表示编译时异常。 如下Throwable类中的常用方法: 这些方法都用于获取异常信息。由于Error和Exception继承自Throwable类，所以他们都拥有这些方法。 try…catch和finally由于发生异常导致程序立即终止，所以无法继续向下执行了。为了解决这样的问题，Java中提供了一种对异常进行处理的方式–异常捕获。异常捕获通常使用try…catch语句，具体格式如下。 12345try&#123; //程序代码块 &#125;catch(ExceptionType(Exception类及其子类)e)&#123; //对ExceptionType的处理 &#125; 其中，在try代码块中编写可能发生的异常的Java语句，catch代码块中编写针对异常进行处理的代码。当try代码块中的程序发生异常，系统会将这个异常的信息封装成一个异常的对象，并将这个对象传递给catch代码块。catch代码块需要一个参数指明它所能够接收的异常类型，这个参数的类型必须是Exception类或其他子类。 在try代码块中，发生异常语句后面的代码是不会被执行的 有时候会希望有些语句无论程序是否发生异常都要执行，这时就可以在try···catch语句后面加一个finally代码块。 在程序设计时，经常会在try···catch后使用finally代码块来完成必须要做的事情，例如释放资源。 需要注意的是，finally中的代码块在一般情况下是不会执行的，那就是在try···catch中执行了System.exit(0)语句。System.exit(0)表示退出当前的Java虚拟机，Java虚拟机停止了，任何代码都不能再执行了。 throws关键字针对这种情况，Java中允许在方法的后面使用throw关键字对外声明该方法有可能发生异常，这样调用者在调用方法时，就明确地知道该方法有异常，并且必须在程序中的异常进行处理，否则编译不能通过。 throws关键字声明抛出异常的语法格式如下。 1234修饰符 返回值类型 方法名([参数1,参数2···])throws ExceptionType1[ ,Exception Type2····]&#123;&#125; 从上述语法格式中可以看出，throw关键字需要写在方法声明的后面，throws后面需要声明方法中发生异常的类型，通常将这种做法称为方法声明抛出一个异常。 运行时异常与编译时异常在实际开发过程中，经常会在程序编译时产生一些异常，而这些异常必要进行处理，这种异常被称为编译时异常，也称为checked异常。另外还有一种异常是在程序程序运行时产生的，这种异常即使不编写异常处理代码，依然可以通过编译，因此被称为运行时异常，也称为unchecked异常。 编译时异常 在Java中，Exception类除了RuntimeException类及其子类外都是编译时异常。编译时异常的特点是Java编译器会对其进行检查，如果出现异常就必须对异常进行处理，否则程序无法通过编译。 处理编译时期的异常有二种方式，具体如下。 使用try···catch语句对异常进行捕获。 使用throws关键字声明抛出异常，调用者对其处理。 运行时异常 RuntimeException类及其子类都是运行时异常。运行时异常的特点是Java编译器不会对其进行检查。也就是说，当程序中出现这类异常时，即使没有使用try···catch语句捕获或使用throws关键字声明抛出，程序也能编译通过。运行时异常一般是由程序中的逻辑错误引起的，在程序运行时无法恢复。 自定义控制JDK中定义了大量的异常类，虽然这些异常类可以描述编程时出现的大部分异常情况，但是在程序开发中有时可能需要描述程序中特有的异常情况。在Java中允许用户自定义异常，但自定义异常的异常类必须继承自Exception或其子类。 在实际开发中，如果没有特殊的要求，自定义的异常类只需继承Exception类，在构造方法中使用super()语句调用Exception的构造方法即可。 throw关键字用于在方法中声明抛出异常的实例化对象，其语法格式如下。 throw Exception 异常对象 在一个方法内使用throw关键字抛出异常对象时，需要try···catch语句对抛出的异常进行处理。 访问控制在Java中，针对类、成员方法和属性提供了4种访问级别，分别是private、default、protected和public。 private(类访问级别):如果类的成员被private访问控制符来修饰，则这个成员只能被该类的其他成员访问，其他类无法直接访问。类的良好封装就是通过private关键字来实现的。 default(包访问级别):如果一个类或者类的成员不使用任何访问控制符修饰，则称它为默认访问控制级别，这个类或者类的成员只能被本包中的其他类访问。 protected(子类访问级别):如果一个类的成员被protected访问控制符修饰，那么这个成员既能被同一个包下的其他类访问，也能被不同包下该类的子类访问。 public(公共访问级别):这是一个最宽松的访问控制级别，如果一个类或者类的成员被public访问修饰符修饰，那么这个类或者类成员能被所有的类访问，不管访问类与被访问类是否在同一个包中。 本章小结USB接口程序设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package kang;//定义一个名称为USB的接口public interface USB &#123; void turnOn();//启动 void turnOff();//关闭&#125;package kang;//鼠标public class Mouse implements USB &#123; public void turnOn()&#123; System.out.println(&quot;鼠标打开了&quot;); &#125; public void turnOff()&#123; System.out.println(&quot;鼠标关闭了&quot;); &#125;&#125;package kang;//键盘public class KeyBoard implements USB &#123; public void turnOn()&#123; System.out.println(&quot;键盘打开了&quot;); &#125; public void turnOff()&#123; System.out.println(&quot;键盘关闭了&quot;); &#125;&#125;package kang;//麦克风public class Mic implements USB &#123; public void turnOn()&#123; System.out.println(&quot;麦克风打开了&quot;); &#125; public void turnOff()&#123; System.out.println(&quot;麦克风关闭了&quot;); &#125;&#125;package kang;//计算机public class Computer &#123; //计算机上的USB插槽 private USB[] usbArr = new USB[4]; //向计算机连接一个USB设备 public void add(USB usb)&#123; //循环遍历所有插槽 for(int i=0;i&lt; usbArr.length;i++)&#123; //如果发现一个是空的 if(usbArr[i]==null)&#123; //将usb设备连接在这个插槽上 usbArr[i]=usb; //连接上以后循环结束 break; &#125; &#125; &#125; //计算机开机功能 public void powerOn()&#123; //循环遍历所有插槽 for(int i=0;i&lt;usbArr.length;i++)&#123; //如果发现有设备 if(usbArr[i]!=null)&#123; //将USB设备启动 usbArr[i].turnOn(); &#125; &#125; System.out.println(&quot;计算机开机成功&quot;); &#125; //计算机关机功能 public void powerOff()&#123; for(int i=0;i&lt;usbArr.length;i++)&#123; if(usbArr[i]!=null)&#123; usbArr[i].turnOff(); &#125; &#125; System.out.println(&quot;计算机关机成功&quot;); &#125;&#125;package kang;//测试类 class Task01Test &#123; public static void main(String[] args)&#123; //实例化计算机对象 Computer c = new Computer(); //向计算机中添加鼠标、麦克风和键盘设备 c.add(new Mouse()); c.add(new Mic()); c.add(new KeyBoard()); c.powerOn();//启动计算机 System.out.println(); c.powerOff();//关闭计算机 &#125;&#125; 模拟物流快递系统程序设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194package www;/* * 交通工具类 * */public abstract class Transportation &#123; private String number; //编号 private String model; //型号 private String admin; //运货负责人 public Transportation()&#123; super(); //可省略 &#125; public Transportation(String number,String model,String admin)&#123; this.number=number; this.model = model; this.admin=admin; &#125; //运输方式 public abstract void transport(); //编号 public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; //型号 public String getModel() &#123; return model; &#125; public void setModel(String model) &#123; this.model = model; &#125; //负责人 public String getAdmin() &#123; return admin; &#125; public void setAdmin(String admin) &#123; this.admin = admin; &#125;&#125;package www;/* * 定义保养借口，具有保养功能 */public interface Careable &#123; //保养方法 public abstract void upKeep();&#125;package www;/* * 专用运输车类 */public class ZTransportation extends Transportation implements Careable &#123; //无参构造 public ZTransportation()&#123; super(); &#125; //有参构造：车辆编号、型号、负责人 public ZTransportation(String number,String model,String admin)&#123; super(number,model,admin); &#125; //运输方法 public void transport()&#123; System.out.println(&quot;运输进行中····&quot;); &#125; //重写车辆保养方法 public void upKeep()&#123; System.out.println(&quot;货物运输车辆保养完毕！&quot;); &#125; &#125;package www;/* * 快递任务 */public class SendTask &#123; private String number;//快递单号 private double goodsWeight;//货物重量 public SendTask()&#123; super();//可省略 &#125; public SendTask(String number,double goodsWeight)&#123; this.number= number; this.goodsWeight=goodsWeight; &#125; //送前准备 public void sendBefore()&#123; System.out.println(&quot;订单开始处理，仓库验货中···&quot;); System.out.println(&quot;货物重量:&quot;+this.getGoodsWeight()+&quot;kg&quot;); System.out.println(&quot;货物检验完毕！&quot;); System.out.println(&quot;货物填装完毕！&quot;); System.out.println(&quot;运货人已通知&quot;); System.out.println(&quot;快递单号:&quot;+this.getNumber()); &#125; //发送货物 public void send(Transportation t,GPS tool)&#123; System.out.println(&quot;运货人&quot;+t.getAdmin()+&quot;正在驾驶编号为&quot;+t.getNumber()+&quot;的&quot;+t.getModel()+&quot;发送货物!&quot;); t.transport(); String showCoordincate = tool.showCoordinate(); System.out.println(&quot;货物当前的坐标为:&quot;+showCoordincate); &#125; public void sendAfter(Transportation t)&#123; System.out.println(&quot;货物运输任务完成!&quot;); System.out.println(&quot;运货人&quot;+t.getAdmin()+&quot;正在驾驶编号为&quot;+t.getNumber()+&quot;的&quot;+t.getModel()+&quot;已归还!&quot;); &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public double getGoodsWeight() &#123; return goodsWeight; &#125; public void setGoodsWeight(double goodsWeight) &#123; this.goodsWeight = goodsWeight; &#125; &#125;package www;/* * 定义GPS借口，具备GPS定位功能 */public interface GPS &#123; //显示坐标的方法 public String showCoordinate();&#125;package www;/* * 定义一个手机类，实现GPS接口，拥有定位功能 */class Phone implements GPS &#123; public Phone()&#123;//空参构造 super(); &#125; //定位方法 public String showCoordinate()&#123; String location = &quot;193.485&quot;; return location; &#125;&#125;package www;public class Task02Test &#123; /** * 定义测试类 */ public static void main(String[] args) &#123; // 快递任务类对象 SendTask task = new SendTask(&quot;HYX600235&quot;,76.34); //调用送前准备方法 task.sendBefore(); //创建交通工具对象 System.out.println(&quot;=========================&quot;); //创建GPS工具对象 ZTransportation t = new ZTransportation(&quot;Z025&quot;,&quot;大本&quot;,&quot;小韩&quot;); //将交通工具与GPS工具传入送货方法 Phone p = new Phone(); //调用送后操作方法 task.send(t,p); System.out.println(&quot;=========================&quot;); task.sendAfter(t); t.upKeep(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序入门-布局]]></title>
    <url>%2F2019%2F02%2F15%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8-%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[选择器类选择器 class .点号开始 文件名不要用中文 多个地方被使用 一个地方可以使用多个 后面的优先级高 element 全局 使用不多 组合选择器,逗号分隔Id选择器#井号开始后代选择器，空格分隔颜色和字体颜色三原色:由于人类肉眼有三种不同颜色的感光体，因此所见的色彩空间通常可以由三种基本色表达。 红，绿，蓝。 1234/* 红 绿 蓝 */ color: rgb(255, 255, 255)/*2^8-1*/ color: #ffffff;/*十六进制*/ color: red;/*别称*/ 那些地方使用颜色，字体，背景，边框，阴影 1234color: blue; /*字体颜色*/ background-color: #000000;/*背景颜色*/ box-shadow: 0 0 5px #5F687E;/*阴影颜色*/ border: 4px solid #ffffff;/*边框颜色*/ 字体123font-size: 17px; /*字体大小*/font-family: &quot;宋体&quot;; /*字体样式 尽量不要动*/font-weight: bold; /*字体加粗*/ 盒模型 外边距、内边距、边框和内容部分 做小程序时候尽量不用px，使用% box-sizing content-box border-box(不懂不要动) 1234margin: 10px;/*外边距 px像素点*/padding: 10px;/*内边距*/border: 10px dashed #000000;/*边框*//* 宽度 样式 颜色 */ 定位position 元素的定位方式 static 静态 relative 相对 absolute 绝对 fixed 固定]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象-上]]></title>
    <url>%2F2019%2F02%2F11%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[面向对象的概念面向对象是一种符合人类思维的编程思想。现实生活中存在各种形态的不同的事物，这些事物之间存在着各种各样的联系。在程序中使用对象来映射现实中的事物，使用对象的关系来描述事物之间的联系，这种思想就是面向对象。 面向过程：面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一一实现，使用的时候依次调用就可以了。 面向对象则是把构成问题的事务按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。当然，一个程序会包含多个对象，通过多个对象的相互配合来实现应用程序的功能，这样当应用程序功能发生变动时，只需要修改个别的对象就可以了，从而使代码更容易得到维护。面向对象的特点可以概括为封装性、继承性、多态性。 封装性 封装是面向对象的核心思想，将对象的属性和行为封装起来，不需要让外界知道具体实现细节，这就是封装思想。 继承性 继承性主要描述的是类与类之间的关系，通过继承，可以在无需重新编写原有类的情况下，对原有类的功能进行拓展。继承不仅增强了代码的复用性，提高了开发效率，还为程序的维护补充提供了便利。 多态性 多态性指的是在程序中允许出现重名现象，它指在一个类中定义的属性和方法被其他类继承后，它们可以具有不同的数据类型或表现出不同的行为，这使得同一个属性和方法在不同的类中具有不同的语义。 类与对象面向对象的编程思想，力图让程序中对事物的描述与该事物在现实中的形态保持一致。为了做到这一点，面向对象的思想中提出了二个概念，即类和对象。类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体。 类用于描述多个对象的共同特征，它是对象的模板。对象用于描述现实中的个体，它是类的实例。对象是根据类创建的，并且一个类可以对应多个对象。 类的定义类是对象的抽象，它用于描述一组对象的共同特征和行为。类中可以定义成员变量和成员方法，其中成员变量用于描述对象的特征，也被称作属性；成员方法用于描述对象的行为，可以简称为方法。实例如下： 1234567class Person&#123; int age; //定义int类型的变量age //定义speak（）方法 void speak()&#123; System.out.println(&quot;大家好，我今年&quot;+age+&quot;岁&quot;); &#125;&#125; Person 是类名，age是成员变量，speak()是成员方法。在成员方法speak()中可以直接访问成员变量age。 对象的创建与使用应用程序想要完成具体的功能，仅有类是远远不够的，还需要根据类创建实例对象。在Java程序中可以使用new关键字来创建对象，如下： 12类名 对象名称 = new 类名();Person p = new Person();//例子 “new Person()”用于创建Person类的一个实例对象，”Person p”则是声明了一个Person类型的变量p。中间的等号用于将Person对象在内存中的地址赋值给变量p，这样变量p便持有了对象的引用。为了方便描述，通常会将变量p引用的对象简称为p对象。 在创建Person对象后，可以通过对象的引用来访问对象所有的成员。 对象引用.对象成员 具体如下实例 p1、p2分别引用了Person类的二个实例对象。p1对象和p2对象是二个完全独立的个体，它们分别拥有各自的age属性，对p1对象的age属性进行赋值并不会影响到p2对象age的属性。 在实例化对象时，Java虚拟机会自动为成员变量进行初始化，针对不同类型的成员变量，Java虚拟机会赋予不同的初始值。如下所示： 当对象被实例化以后，在程序中可以通过对象的引用变量来访问该对象的成员。需要注意的是，当没有任何变量引用这个对象时，它将成为垃圾对象，不能在被使用。 类的设计例子：先定义一个学生类(Student),在这个类中定义二个属性name、age，分别表示学生的姓名和年龄，定义一个方法introduce()表示学生的自我介绍。 123456789public class Student &#123; String name; //定义一个姓名属性 int age; //定义一个年龄属性 public void introduce()&#123; //方法中打印属性name和age的值 System.out.println(&quot;大家好，我叫&quot;+name+&quot;,我今年&quot;+age+&quot;岁！&quot;); &#125;&#125; 类的封装所谓类的封装是指在定义一个类时，将类中的属性私有化，即使用private关键字来修饰。私有属性只能在它所在类中被访问，如果外界想要访问私有属性，需要提供一些使用public修饰的公有方法，其中包括用于获取属性值的getXxx方法和设置属性值的setXxx方法。具体如下： 当获取年龄不合法时，age属性没有被赋值，认为初值0。 构造方法实例化一个类的对象以后，如果要为这个对象中的属性赋值，则必须要通过直接访问对象的属性或调用setXxx方式才可以。如果需要在实例化对象的同时就为这个对象属性进行赋值，可以通过构造方法来实现。构造方法是类的一个特殊成员，它会在类实例化对象时被自动调用。 构造方法的定义在一个类中定义的方法如果同时满足以下3个条件，该方法称为构造方法。 方法名与类名相同。 在方法名的前面没有返回值类型的声明。 在方法中不能使用return语句返回一个值，但是可以单独写return语句来作为方法的结束。 如下： 构造方法的重载与普通方法一样，构造方法也可以重载，在一个类中可以定义多个构造方法，只要每个构造方法的参数类型或参数个数不同即可。在创建对象时，可以通过不同的构造方法来为不同的属性进行赋值。如下例子： 注意： 在Java中的每一个类都至少有一个构造方法，如果在一个类中没有定义构造方法，系统会自动为这个类创建一个默认的构造方法，这个默认的构造方法没有参数，在其方法体中没有任何代码，即什么都不做。 private关键字修饰的构造方法Person()只能在Person类中被访问。也就是说，Person()构造方法是私有的，不能被外界调用，也就无法在类的外部创建该类的实例对象。因此，为了方便实例化对象，构造方法通常会使用public来修饰。 this关键字为了解决导致成员变量和局部变量的名称冲突，Java中提供了一个关键字this来指代当前对象，用于在方法中访问对象的其它成员。 this关键字在程序中的3种常见用法 通过this关键字可以明确地去访问一个类的成员变量，解决与局部变脸名称冲突问题。 通过this关键字调用成员方法。 构造方法是在实例化对象时被Java虚拟机自动调用的，在程序中不能像调用其他方法一样去调用构造方法，但可以在一个构造方法中使用“this([参数 1,参数 2 ….])”的形式来调用其他的构造方法。 在使用this调用类的构造方法时，应注意以下几点。 只能在构造方法中使用this调用其他的构造方法，不能在成员方法中使用。 在构造方法中，使用this调用构造方法的语句必须位于第一行，且只能出现一次。 不能在一个类的二个构造方法中使用this互相调用。 垃圾回收在Java中，当一个对象成为垃圾后仍会占有内存空间，时间一长，就会导致内存空间的不足。针对这种情况，Java中引用了垃圾回收机制。有了这种机制，程序员不需要过多的关心垃圾对象回收的问题，Java虚拟机会自动回收垃圾对象所占用的内存空间。 一个对象在成为垃圾后会暂时地保存到内存中，当这样的垃圾堆积到一定程度时，Java虚拟机就会启动垃圾回收器将这些垃圾对象从内存中释放，从而使程序获得更多的内存空间。除了等待Java虚拟机进行自动垃圾回收以外，还可以通过调用System.gc()方法来通知Java虚拟机立即进行垃圾回收。当一个对象在内存中被释放时，它的finalize()方法会自动被调用，因此可以在类中通过定义finalize()方法来观察对象何时被释放。 static关键字在Java中定义了一个static关键字，它用于修饰类的成员，如成员变量、成员方法以及代码块等，被static修饰的成员具备一些特殊性。 静态变量在定义一个类时，只是在描述某类事物的特征和行为，并没有产生具体的数据。只有通过new关键字创建类的实例对象后，系统才会为每个对象分配空间，存储各自的数据。有时候，开发人员会希望某些特定的数据只有一份，而且能够被一个类的所有实例对象所共享。 在一个Java类中，可以使用static关键字来修饰成员变量，该变量被称作静态变量。静态变量被所有实例共享，可以使用”类名.变量名”的形式来访问。 static关键字只能用于修饰成员变量，不能用于修饰局部变量，否则编译会报错。 静态方法在实际开发过程中，开发人员希望在不创建对象的情况下就可以调用某个方法，换句话说也就是使该方法不必和对象绑在一起。要实现这样的效果，只需要在类中定义的方法前加上static关键字即可，通常称这种方法为静态方法。同静态变量一样，静态方法可以使用”类名.方法名”的方式来访问，也可以通过类的实例对象来访问。 在一个静态方法中只能访问用static修饰的成员，原因在于没有被static修饰的成员需要先创建对象才能访问，而静态方法可以在被调用时可以不创建任何对象。 静态代码块在Java类中，使用一对大括号包围起来的若干行代码被称为一个代码块，使用static关键字修饰代码块称为静态代码块。当类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块只执行一次。在程序中，通常会使用静态代码块来对类的成员变量进行初始化。 Java虚拟机首先会加载类Example01,在加载类的同时就会执行该类的静态代码块，紧接着会调用main()方法。在该方法中创建了二个Person对象，但在二次实例化对象的过程中，静态代码块中的内容只输出一次，这就说明静态代码块在类第一次使用时才会被加载，而且只会加载一次。 成员内部类在Java中，允许在一个类的内部定义一个类，这样的类称作内部类，这个内部类所在的类称作外部类。根据内部类的位置、修饰符和定义的方式可分为成员内部类、静态内部类、方法内部类。 在成员内部类中，可以访问外部类的成员。 如果想通过外部类去访问内部类,则需要通过外部类对象去创建内部类对象，创建内部类对象的具体语法格式如下： 外部类名.内部类名 变量名 = new 外部类名().new 内部类名(); 需要注意的是，如果内部类被声明私有，外界将无法访问。 本章小结超市购物程序设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package cn.itcast.shop;public class Product &#123;//商品 private String proName;//商品名 public String getProName()&#123; return proName; &#125; public void setProName(String proName)&#123; this.proName = proName; &#125;&#125;package cn.itcast.shop;public class Market &#123;//超市 private String marketName;//超市名 private Product[] productArr;//超市的仓库，里面有若干商品 public String getMarketName()&#123; return marketName; &#125; public void setMarketName(String marketName)&#123; this.marketName = marketName; &#125; public Product[] getProductArr()&#123; return productArr; &#125; public void setProductArr(Product[] productArr)&#123; this.productArr = productArr; &#125; Product sell(String name)&#123;//卖货，指定商品名 //循环遍历仓库中每一个商品 for(int i=0;i&lt;productArr.length;i++)&#123; //如果商品名称和要买的商品一致 if(productArr[i].getProName()==name)&#123; return productArr[i];//将该商品返回 &#125; &#125; return null;//循环结束后没有找到商品，返回null代表没有买到 &#125;&#125;package cn.itcast.shop;public class Person &#123; //人 private String name; //人名 public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name=name; &#125; //购物，指定去那个超市，商品名 Product shopping(Market market,String name)&#123; //调用超市的卖货方法，指定商品名，把卖出的结果返回 return market.sell(name); &#125;&#125;package cn.itcast.shop;public class Shopping &#123; public static void main(String[] args)&#123; //创建商品对象，给名字赋值 Product p1 = new Product(); Product p2 = new Product(); Product p3 = new Product(); Product p4 = new Product(); Product p5 = new Product(); p1.setProName(&quot;电视机&quot;); p2.setProName(&quot;洗衣机&quot;); p3.setProName(&quot;豆浆机&quot;); p4.setProName(&quot;空调机&quot;); p5.setProName(&quot;吹风机&quot;); //创建超市对象，给超市名字赋值，给仓库赋值 Market m = new Market(); m.setMarketName(&quot;家乐福&quot;); m.setProductArr(new Product[]&#123;p1,p2,p3,p4,p5&#125;); //创建人对象，给名字赋值 Person p = new Person(); p.setName(&quot;小韩&quot;); //调用购物方法，指定超市和商品名，得到购物结果 Product result = p.shopping(m, &quot;豆浆机&quot;); //根据结果进行判断 if(result!=null)&#123; System.out.println(p.getName()+&quot;在&quot;+m.getMarketName()+&quot;买到了&quot;+result.getProName()); &#125;else&#123; System.out.println(p.getName()+&quot;白跑了一趟，在&quot;+m.getMarketName()+&quot;什么也没有买到了&quot;); &#125; &#125;&#125; 银行新用户现金业务办理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package cn.itcast.bank;public class Bank &#123; static String bankName;//定义静态变量银行名称 private String name; //储户姓名 private String password; //密码 private double balance;//账户余额 private double turnover;//交易额 //静态方法，打印出银行欢迎语句 static void welcome()&#123; System.out.println(&quot;欢迎来到&quot;+bankName+&quot;--------------&quot;); &#125; //构造方法 开户 public Bank(String name,String password,double turnover)&#123; //将变量赋值给成员变量 this.name=name; this.password=password; this.turnover=turnover; this.balance=turnover-10; System.out.println(name+&quot;开户成功，账户余额&quot;+balance); &#125; //存款 public void deposit(double turnover)&#123; balance = balance+turnover; System.out.println(name+&quot;您好,您的账户 已存入&quot;+turnover+&quot;元，当前余额&quot;+balance+&quot;元&quot;); &#125; //取款 public void withdrawal(String password,double turnover)&#123; //根据传入的变量与成员变量比对，判断密码是否正确 if(this.password!=password)&#123; System.out.println(&quot;输入密码错误&quot;); return; &#125; //判断余额是否充足 if(balance-turnover&gt;0)&#123; balance=balance-turnover; System.out.println(name+&quot;您好，您的账户 以取出&quot;+turnover+&quot;元，当前余额&quot;+balance+&quot;元&quot;); &#125;else&#123; System.out.println(&quot;对不起，账户余额不足！&quot;); &#125; &#125; //静态方法，打印出银行欢迎下次光临语句 static void welcomeNext()&#123; System.out.println(&quot;欢迎下次光临&quot;+bankName+&quot;-----------&quot;); &#125;&#125;package cn.itcast.bank;public class Trade &#123; public static void main(String[] args)&#123; //定义一家银行（给静态变量赋值，可以直接使用类名访问） Bank.bankName=&quot;招商银行&quot;; //调用静态方法，银行打印欢迎语句 Bank.welcome(); //通过构造方法进行开户操作 Bank bank = new Bank(&quot;小梦&quot;,&quot;654321&quot;,100.0); //进行存款操作 bank.deposit(500.00); //取款时密码错误，取款失败 bank.withdrawal(&quot;1234565&quot;, 200); //取款时余额不足时，取款失败 bank.withdrawal(&quot;654321&quot;, 1000.00); //取款时密码正确，余额充足，取款成功 bank.withdrawal(&quot;654321&quot;, 200.00); //调用静态方法，银行打印道别语句 Bank.welcomeNext(); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序入门-基本操作]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[微信小程序简介微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 编译工具简介为了帮助开发者简单和高效地开发和调试微信小程序，我们在原有的公众号网页调试工具的基础上，推出了全新的 微信开发者工具，集成了公众号网页调试和小程序调试两种开发模式。 编译工具使用步骤 入门hello world 制作一个小程序材料准备 写代码 上传 总结小程序其实就是根据网页设计的HTML和css进行一种修改。]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 new year flag]]></title>
    <url>%2F2019%2F02%2F02%2F2019-new-year-flag%2F</url>
    <content type="text"><![CDATA[完成一项以后 后面画一个对勾 独立开发一个微信小程序 成为大佬 学习轮滑 学会滑板 教会弟弟妹妹滑板、轮滑 学习一门主流框架 微信公共号开始一周一次 减肥三十斤 追一年princess 合伙开发一个校园app 学习一些新东西 得到一份好的实习机会 给社团以后的发展铺好路 一个月更新二篇博客（2019/2/2 21:26 未完待续 ）]]></content>
      <tags>
        <tag>2019 flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[two]]></title>
    <url>%2F2019%2F01%2F25%2Ftwo%2F</url>
    <content type="text"><![CDATA[海底月是天上月，眼前人是心上人。向来心是看客心，奈何人是剧中人。 –张爱玲《倾城之恋》 我希望有个如你一般的人 如山间清爽的风 如古城温暖的光 从清晨到夜晚 由山野到书房 只要最后是你 就好 –张嘉佳《从你的全世界路过》 我最讨厌说的就是本可以三个字，状况都发生了才说本可以有个屁用！ –肖海洋《一起同过窗》 所谓朋友，就是在看似一成不变中悄悄靠近，幡然醒悟之时，却已反常到无话不谈。 –毕十三《一起同过窗》 我们精心策划，按部就班，等待某一时刻的发生，也许它真的发生了，却和你想象的有点不一样。 –路桥川《一起同过窗》 我真的好讨厌你，讨厌你这么喜欢另一个女生，我讨厌你对我无视的态度，我讨厌你忘记我，我好讨厌你，真的好讨厌你。 –林洛雪《一起同过窗》 如果爱情不光是甜蜜，同样有伤痕，有痛苦，那我的毫无保留，到底值不值得。 –顾一心《一起同过窗》 其实你的内心，比其他人要执着许多，只是缺少果断，所以别的人会走的很快，而你会走的很长。 –叶吉平《一起同过窗》 “不舍”和“留恋”怎么会一样呢？况且你做到的是“不”和“舍”，而我想要的是“留”和“恋”。 –李殊词《一起同过窗》 但是，我虽然烂，我每次喜欢上一个女孩的时候，我都真心地觉得她是一个很可爱的姑娘。或者说，在我眼里，每个女孩子都有可爱的一面，我从来不觉得女孩子有任何的缺点。 –任逸帆《一起同过窗》 我曾以为黎明之后，太阳就会升起，就会有光。最近才知道，原来黑夜和黎明之前，还有一个时刻，叫破晓。破晓之后，新的一天才正式开始。 –钟白《一起同过窗》]]></content>
      <tags>
        <tag>优美句子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程基础]]></title>
    <url>%2F2019%2F01%2F25%2FJava%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java的基本语法Java代码的基本格式 Java中的程序代码可分为结构定义语句和功能执行语句，其中，结构定义语句用于声明一个类或者方法，功能执行语句用于实现具体的功能。每条功能执行语句的最后都必须用英文分号(;)结束。 Java语言严格区分大小写。 为了便于阅读，尽量使自己的代码整齐美观、层次清晰。 Java程序中一个太长的字符串不能分开在二行中书写。为了其他原因，可以使用（+）号将二个字符串链接起来。 Java中的注释 单行注释 int a; //定义一个整形变量 多行注释 12345678/* int a; //定义一个整形变量 public static void main(String[] args)&#123; printRectangle(4,3); printRectangle(2,3); printRectangle(6,10); &#125; */ 文档注释,文档注释是以“/*”开头，并在注释内容末尾以“/”结束。文档注释是对一段代码概括性的解释说明，可以使用Javadoc命令将文档注释提取出来生成帮助文档。 Java中的标识符在编程过程中，经常需要在程序中定义一些符号来标记一些名称，如包名、类名、方法名、参数名、变量名等，这些符号被称为标识符。标识符可以由字母、数字、下划线和美元符号（$）组成，但标识符不能以数字开头，不能是Java中的关键字。 为了增加代码可读性，初学者应该遵循以下规则。 包名所有字母一律小写。例如：cn.itcast.test 类名和接口名每个单词的首字母都要大写。例如：ArrayList 常量名所有字母都大写，单词之间用下划线链接。例如：DAY_OF_MONTH 变量名和方法名的第一个单词首字母小写，从第二个单词开始，每个单词首字母大写。例如：lineNumber 在程序中，应尽量使用有意义的英文单词来定义标识符，使得程序便于阅读。例如：password表示密码 Java中的关键字关键字是编程语言里事先定义好并赋予了特殊含义的单词。 Java所有关键字：abstract、continue、for、new、switch、assert、default、goto、package（用于包的声明）、synchronized、boolean、do、if、private、this、break、double、implements、protected、throw、byte、else、import（用于引入包）、public、throws、case、enum、instanceof、return、transient、catch、extends、int、short、try、char、final、interface、static、void、class（用于类的声明）、finally、long、strictfp、volatile、const、float、native、super、while。 所有的关键字都是小写的。 程序中的标识符不能不能以关键字命名。 const和goto是保留字关键字，虽然在Java中还没有任何意义，但在程序中不能用来作为自定义的标识符。 true、false和null不属于关键字，他们是一个单独标识类型，不能直接使用。 Java中的常量常量就是在程序中固定不变的值，是不能改变的数据。在Java中，常量包括整形常量、浮点数常量、布尔常量、字符常量等。 整形变量整形变量是整数类型的数据，有二进制、八进制、十进制、十六进制4中表示形式。 二进制：由数字0和1组成的数字序列。前面要以0b或0B开头，目的是为了和十进制进行区分，如0b01101100。 八进制：以0开头并且其后由0~7范围内（包括0和7）的整数组成的数字序列，如0342。 十进制：由数字0~9范围内（包括0和9）的整数组成的数字序列，如198。 十六进制：以0x或者0X开头并且其后由0~9、A~F（包括0和9、A和F，字母不区分大小写）组成的数字序列，如0x25AF。 注意：八进制必须以0开头，十六进制必须以0X或0x开头，整数以十进制表示时，开头第一位不能是0，0本身除外。 浮点数常量浮点数常量就是在数学中用到的小数，分为float单精度浮点数和double双精度浮点数二种类型。其中，单精度浮点数后面以F或f结尾，而双精度浮点数则以D或d结尾。当然，在使用浮点数时也可以在结尾处不加任何后缀，此时，虚拟机会默认为double双精度浮点数。浮点数常量还可以通过指数形式来表示。 2e3f 3.6d 0f 3.84d 5.022e+23f 字符常量字符常量用于表示一个字符，一个字符常量要用一对英文半角格式的单引号’’引起来，它可以是英文字母、数字、标点符号以及由转义序列来表示的特殊字符。 &#39;a&#39; &#39;1&#39; &#39;&amp;&#39; &#39;\r&#39; &#39;\u0000&#39; ‘\u0000’表示一个空白字符，即单引号之间没有任何字符。之所以能这样表示，是因为Java采用的是Unicode字符集，Unicode字符以\u开头，空白字符在Unicode码中对应的值为’\u0000’。 字符串常量字符串常量用于表示一串连续的字符，一个字符串常量要用一对英文半角格式的双引号(“”)引起来。 &quot;helloworld&quot; &quot;123&quot; &quot;welcome \n xxx&quot; &quot;&quot; 一个字符串可以包含一个字符或者多个字符，也可以不包含任何字符，即长度为零。 布尔常量布尔常量即布尔型的二个值true和false，该常量用于区分一个事物的真假。 null常量null常量只有一个值null，表示对象的引用为空。 Java中的变量变量的定义在程序运行期间，随时可能产生一些临时数据，应用程序会将这些数据保存在一些内存单元中，每个内存单元都用一个标识符来标识。这些内存单元被称为变量，定义的标识符就是变量名，内存单元中存储的数据就是变量的值。 变量的数据类型Java是一门强类型的编程语言，它对变量的数据类型有严格的限定。定义变量时必须声明变量的类型，在为变量赋值时必须赋予和变量同一类型的值，否则程序会报错。 在Java中，变量的数据类型分为二种，即基本数据类型和引用数据类型。Java中所有的数据类型如下图所示： 整数类型变量整数类型变量用来存储整数数值，即没有小数部分的值。在Java中，为了给不同大小范围内的整数合理分配储存空间，整数类型分为4种不同的类型:字节型(byte)、短整型(short)、整型(int)、长整型(long)。4种类型所占的存储空间的大小以及取值范围如下图所示。 在为一个long类型的变量赋值时，所赋值的后面要加上一个字母(L或者l) 浮点数类型变量浮点数类型变量用来储存小数数值。在Java中，浮点数类型分为二类：单精度浮点数(float)和双精度浮点数(double)。double类型比float类型更精确。具体如下图所示。 字符类型变量字符类型变量用于存储一个单一字符，每个char类型的字符变量都会占有2个字节。在给char类型的变量赋值时，需要用一对英文半角格式的单引号’’把字符括起来，也可以将char类型的变量赋值为0~65535范围内的整数，计算机会自动将这些整数转化为所对应的字符。 布尔类型变量布尔类型变量用来储存布尔值，在Java中用boolean表示，该类型的变量只有二个值，即true和false。具体如下所示12boolean flag=false; //声明一个boolean类型变量，初始值为falseflag = true; //改变flag变量的值为true 变量的类型转换在程序中，当把一种数据类型的值赋予给另一种数据类型的变量时，需要进行数据类型转换。根据转换方式的不同，数据类型转换可分为二种:自动类型转换和强制类型转换。 自动类型转换自动类型转换也叫隐式类型转换，指的是二种数据类型在转换的过程中不需要显示地进行声明。要实现自动类型转换，必须同时满足二个条件，第一个是二种数据类型彼此兼容，第二是目标的类型的取值范围大于源类型的取值范围。 整数类型之间可以实现转换，如byte类型的数据可以赋值给short、int、long类型的变量，short、char类型的数据可以赋值给int、long类型的变量，int类型的数据可以赋值给long类型的变量。 整数类型转换为float类型，如byte、char、short、int类型的数据可以赋值给float类型的变量。 其他类型转换为double类型，如byte、char、short、int、long、float类型的数据可以赋值给double类型的变量。 强制类型转换强制类型转换也称为显示类型转换，指的是二种数据类型之间的转换需要进行显示的声明。当二种类型彼此不兼容，或者目标类型取值范围小于源类型时，自动类型转换无法进行，这时就需要进行强制类型转换。 需要进行强制类型转换，具体格式如下 12目标类型 变量名 = (目标类型) 值;byte b = (byte) num; 在对变量进行强制类型转换时，会发生取值范围较大的数据类型向取值范围较小的数据类型的转换，会很容易造成数据精度的丢失。 变量的作用域变量需要先定义后使用，但并不意味着在变量定义之后的语句中一定可以使用该变量。变量需要在它的作用范围内才可以被使用，这个作用范围被称为变量的作用域。在程序中，变量一定会被定义在某一对大括号中，该大括号所包含的代码区域便是这个变量的作用域。具体如下图: Java中的运算符在程序中经常出现一些特殊符号，如+、-*、/、=、&gt;等，这些特殊符号称为运算符。运算符用于对数据进行算术运算、赋值和比较等操作。在Java中，运算符可分为算术运算符、赋值运算符、比较运算符、逻辑运算符等。 算术运算符在数学运算中最常见的就是加减乘除，被称为四则运算。Java中的算术运算符就是用来处理四则运算的符号，这是最简单、最常用的运算符。Java中的算术运算符及其用法。如下图所示： 在进行自增++和自减–的运算时，如果运算符++或–放在操作数的前面则是先进行自增或自减运算，在进行其他运算。反之，如果运算符放在操作数后面则先进行其他运算在进行自增或自减运算。 在进行除法运算时，当除数和被除数都为整数时，得到的结果也是一个整数。如果除法运算有小数参与，得到的结果会是一个小数。 在进行取模(%)运算时，运算结果的正负取决于被模数(%左边的数)的符号，与模数(%右边的数)的符号无关。 赋值运算符赋值运算符的作用就是将常量、变量或表达式的值赋给某一个变量。Java中的赋值运算符及其用法如下图所示： 1234int x,y,z;x=y=z=5; //为3个变量同时赋值int a=b=c=5; //这样写是错误的 在Java中可以通过一条赋值语句对多个变量进行赋值 图中除了“=”,其他的都是特殊的赋值运算符，以“+=”为例，x+=3就相当于x=x+3,首先会进行加法运算x+3,在将运算结果赋值给变量x。 比较运算符比较运算符用于对二个数值或变量进行比较，其结果是一个布尔值，即true或false。Java中的比较运算符及其用法。如下图所示： 注意，不能将比较运算符“==”误写成赋值运算符“=”。 逻辑运算符逻辑运算符用于对布尔型的数据进行操作，其结果仍是一个布尔数据。Java中的逻辑运算符及其用法。如下图所示： 逻辑运算符可以针对结果为布尔值的表达式进行运算。 运算符”&amp;”和”&amp;&amp;”都表示与操作，当且仅当运算符两边操作数都为true时，其结果才为true，否则结果为false。当运算符“&amp;”和“&amp;&amp;”的右边为表达式时，二者在使用上还有一定的区别。在使用“&amp;”进行运算时，无论左边为true或者false，右边的表达式都会进行运算。如果使用“&amp;&amp;”进行运算，当左边为false时，右边的表达式则不会进行运算，因此“&amp;&amp;”被称为短路与。 运算符“|”和“||”都表示或操作，当运算符两边的操作数任何一边的值为true时，其结果为true；当两边的值都为false时，其结果才为false。同与操作类似，“||”表示短路或，当运算符“||”的左边为true时，右边的表达式就不会进行运算。 运算符“^”表示异或操作，当运算符两边的布尔值相同时（都为true或都为false），其结果为false。当两边布尔值不相同时，其结果为true。 运算符的优先级在对一些比较复杂的表达式进行运算时，要明确表达式所有运算符参与运算的先后顺序，通常把这种顺序称作运算符的优先级。Java中的运算符的优先级具体如下图所示： 在编写程序时，尽量使用括号“()”来实现想要的运算顺序，以免产生歧义。 选择结构语句Java中有一种特殊的语句叫作选择语句，它需要对一些条件做出判断，从而决定执行哪一段代码。 if条件语句if语句if语句是指如果满足某种条件，就进行某种处理。123if(条件语句)&#123; 代码块&#125; 判断条件是一个布尔值，当判断条件为true时，{}中的执行语句才会执行。if语句的执行流程如下图所示： if…else语句if…else语句是指如果满足某种条件，就进行某种处理，否则就进行另一种处理。 1234567if(判断语句)&#123; 执行语句1 ...&#125;else&#123; 执行语句2 ...&#125; 判断条件是一个布尔值，当判断条件为true时，if后面{}中的执行语句1会执行。当判断条件为false时，else后面{}中的执行语句2会执行。if…else语句的执行流程图如下图所示： 在Java中有一种特殊的运算叫作三元运算，它和if-else语句类似， “判断条件?表达式1:表达式2” 三元运算会得到一个结果，通常用于对某个变量进行赋值，当判断条件成立时，运算结果为表达式1的值，否则结果为表达式2得值。 if…elseif…else语句if…else if…else语句用于多个条件进行判断，进行多种不同得处理。1234567891011if(判断条件1)&#123; 执行语句1&#125;else if(判断条件2)&#123; 执行语句2&#125;...else if(判断条件n)&#123; 执行语句n&#125;else&#123; 执行语句n+1&#125; switch条件语句switch条件语句也是一种很常见得选择语句，和if条件语句不同，它只能针对某个表达式的值做出判断，从而决定程序执行那一段代码。 123456789101112131415switch(表达式)&#123; case 目标值1: 执行语句1 break; case 目标值2: 执行语句2 break; ... case 目标值n: 执行语句n break; default: 执行语句n+1 break;&#125; 在上面的格式中，switch语句将表达式的值与每个case中的目标值进行匹配，如果找到了匹配的值，会执行对应case后的语句；如果没找到任何匹配的值，就会执行default后的语句。 循环结构语句在Java中有一种特殊的语句叫做循环语句，它可以实现将一段代码重复执行。 while循环语句while语句会反复地进行条件判断，只要条件成立，{}内的执行语句就会执行，直到条件不成立，while循环结束。1234while(循环条件)&#123; 执行语句 ...&#125; 在上面的语法结构中，{}中的执行语句被称作循环体，循环体是否执行取决于循环条件。当循环条件为true时，循环体就会执行。循环体执行完毕时会继续判断循环条件，如条件仍为true则会执行，直到循环条件为false时，整个循环过程才会结束。 do…while循环语句do…while循环语句和while循环语句类似。1234do&#123; 执行语句 ...&#125;while(循环条件); 在上面的语法结构中，关键字do后面{}中的执行语句是循环体。do…while循环语句将循环条件放在了循环体的后面。这就意味着，循环体会无条件执行一次，然后在根据循环条件来决定是否继续执行。do…while循环的执行流程如下图所示： for循环语句for循环语句是最常用的循环语句，一般用在循环次数已知的情况下。 1234for(初始化表达式;循环条件;操作表达式)&#123; 执行语句 ...&#125; 在上面的语法结构中，for关键字后面()中包括了3部分内容—初始化表达式、循环条件和操作表达式,它们之间用(;)分隔，{}中的执行语句为循环体。 1表示初始化表达式，2表示循环条件，3表示操作表达式，4表示循环体，通过序号来具体分析for循环的执行流程。具体如下： 12345678for(1;2;3)&#123; 4&#125;第一步，执行1第二步，执行2，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步第三步，执行4第四步，执行3，然后重复执行第二步第五步，退出循环 循环嵌套嵌套循环是指在一个循环语句的循环体中在定义一个循环语句的语法结构。while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以相互嵌套，其中最常见的是在for循环中嵌套for循环，格式如下。12345678for(初始化表达式;循环条件;操作表达式)&#123; ... for(初始化表达式;循环条件;操作表达式)&#123; 执行语句 ... &#125; ...&#125; 跳转语句（break，continue）跳转语句用于实现循环执行过程中程序流程的跳转。 break语句在switch条件语句和循环语句中都可以使用break语句。当它出现在switch条件语句中时；作用是终止某个case并跳出switch结构。当它出现在循环语句中，作用是跳出循环语句，执行后面的代码。 当break语句出现在嵌套循环中的内层循环，它只能跳出内层循环，如果想使用break语句跳出外层循环，则需要对外层循环添加标记。使用break itcast；语句跳出外层循环。 continue语句continue语句用在循环语句中，它的作用是终止本次循环，执行下一次循环，在循环嵌套语句中，continue语句后面也可以使用标记的方式结束本此外层循环，用法与break语句相似。 方法什么是方法方法就是一段可以重复调用的代码，有些书里也会把方法称为函数。在Java中，声明一个方法的具体语法格式如下： 12345修饰符 返回值类型 方法名 ([参数类型 参数1，参数类型 参数2，...])&#123; 执行语句 ... return 返回值;&#125; 修饰符:方法的修饰符比较多，有对访问权限进行限定的，有静态修饰符static，还有最终修饰符final等。 返回值类型:用于限定方法返回值的数据类型。 参数类型:用于限定调用方法时传入参数的数据类型。 参数名:是一个变量，用于接收调用方法时传入的数据。 return关键字:用于结束方法以及返回指定类型的值。 返回值:被return语句返回的值，该值会返回给调用者。 需要注意的是，方法中的“参数类型 参数1，参数类型 参数2”被称为参数列表，它用于描述方法在被调用时需要接收的参数。如果方法不需要接收任何参数，则参数列表为空，即()内不写任何内容。方法的返回值必须为方法的返回值类型，如果方法中没有返回值，返回值类型要声明为void，此时，方法中return语句可以省略。 方法的重载Java中允许在一个程序中定义多个名称相同的方法，但是参数的类型或个数必须不同，这就是方法的重载。 方法的重载与返回值类型无关，它需要满足二个条件，一是方法名相同，二是参数个数或参数类型不相同。 数组数组是指一组数据的集合，数组中的每个数据被称为元素。数组可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。 数组的定义在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式称作动态初始化。在初始化数组时还有一种方式叫作静态初始化，就是在定义数组的同时就为数组的每个元素赋值。数组的静态初始化有二种方式，具体如下： 121.类型[] 数组名 = new 类型[]&#123;元素,元素,.....&#125;;2.类型[] 数组名 = &#123;元素,元素,.....&#125;; 建议使用第二种方式 当数组被成功创建以后，数组中元素会被自动赋予一个默认值，根据元素类型的不同，默认初始化的值也是不一样的。具体如下图: 数组的常见操作数组遍历在操作数组时，经常需要依此访问数组中的每个元素，这种操作称为数组的遍历。 数组最值在操作数组时，经常需要获取数组元素的最值。 数组排序在操作数组时，经常需要对数组中的元素进行排序。 冒泡排序，不断地比较数组相邻的两个元素，较小者向上浮，较大者往下沉，整个过程和水中气泡上升的原理相似。 多维数组多维数组可以简单地理解为在数组中嵌套数组。 第一种方式: int[][] arr = new int[3][4]; 第二种方式: int[][] arr = new int[3][]; 第三种方式: 1int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4,5,6&#125;,&#123;7,8,9&#125;&#125; 总结情不知所起 一往情深 怎奈何 如花美眷 终不敌 似水流年 缘莫明以由 两厢缘孽 更那堪 拟仙娇娥 难留恋 风花雪月 商场库存清单程序设计12345678910111213141516171819202122232425262728293031323334353637383940//计算商城库存清单功能的实现代码package cn.itcast.chapter01;public class StoreList &#123; public static void main(String[] args)&#123; //苹果笔记本电脑 String macBrand = &quot;MacBookAir&quot;; double macSize = 13.3; double macPrice = 6988.88; String macConfig = &quot;i5处理器4GB内存128G固态硬盘&quot;; int macCount = 5; //联想Thinkpad笔记本电脑 String thinkpadBrand = &quot;ThinkpadT450&quot;; double thinkpadSize = 14.0; double thinkpadPrice = 5999.99; String thinkpadConfig = &quot;i5处理器4GB内存500G硬盘&quot;; int thinkpadCount = 10; //华硕ASUS笔记本电脑 String ASUSBrand = &quot;ASUS-FL5800&quot;; double ASUSSize = 15.6; double ASUSPrice = 4999.50; String ASUSConfig = &quot;i7处理器4GB内存500G固态硬盘&quot;; int ASUSCount = 18; //列表头部 System.out.println(&quot;----------------------------商城库存清单------------------------------&quot;); System.out.println(&quot;品牌型号 尺寸 价格 配置 &quot; + &quot; 库存数&quot;); //列表中部 System.out.println(macBrand+&quot; &quot;+macSize+&quot; &quot;+macPrice+&quot; &quot;+macConfig+&quot; &quot;+macCount); System.out.println(thinkpadBrand+&quot; &quot;+thinkpadSize+&quot; &quot;+thinkpadPrice+&quot; &quot;+thinkpadConfig+&quot; &quot;+thinkpadCount); System.out.println(ASUSBrand+&quot; &quot;+ASUSSize+&quot; &quot;+ASUSPrice+&quot; &quot;+ASUSConfig+&quot; &quot;+ASUSCount); //统计总库存数、库存金额 int totalCount = macCount + thinkpadCount + ASUSCount; double totalMoney = (macCount*macPrice)+(thinkpadCount*thinkpadPrice)+(ASUSCount*ASUSPrice); //列表底部 System.out.println(&quot;--------------------------------------------------------------------&quot;); System.out.println(&quot;总库存数:&quot;+totalCount); System.out.println(&quot;库存商品总金额:&quot;+totalMoney); &#125; &#125; 猜数字游戏12345678910111213141516171819202122232425262728293031package cn.itcast.chapter01;import java.util.Random;import java.util.Scanner;public class GuessNumber &#123; public static void main(String[] args)&#123; //1.通过Random类中的nextInt(int n)方法，生成一个0~9的随机数 int randomNumber =new Random().nextInt(10); System.out.println(&quot;随机数已生成!&quot;); //2.输入猜的数字 System.out.println(&quot;----请输入你猜的数字:----&quot;); Scanner sc = new Scanner(System.in); int enterNumber = sc.nextInt(); //3.通过while循环，进行猜数字对错判断 //猜对，跳出循环，游戏结束 while (enterNumber != randomNumber)&#123; //猜错了，根据结果，给出提示，接着猜数字，游戏继续 if(enterNumber &gt; randomNumber)&#123; //如果猜大了，打印sorry，您猜大了！继续下一次循环 System.out.println(&quot;sorry 您猜大了！&quot;); &#125;else&#123; //如果猜小了，打印sorry，您猜小了！继续下一次循环 System.out.println(&quot;sorry 您猜小了！&quot;); &#125; //输入猜的数字 System.out.println(&quot;----请输入你猜的数字:----&quot;); enterNumber = sc.nextInt(); &#125; System.out.println(&quot;您猜对了！&quot;); &#125;&#125; 随机点名器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package cn.itcast.chapter01;import java.util.Random;import java.util.Scanner;public class CallName &#123; /** * 1.储存全班同学姓名 * 创建一个存储多个同学姓名的容器（数组） * 键盘输入每个同学的姓名，储存到容器中（数组） * @param students */ public static void addStudentName(String[] students)&#123; //键盘输入多个同学姓名储存到容器中 Scanner sc = new Scanner(System.in); for(int i=0;i&lt;students.length;i++)&#123; System.out.println(&quot;储存第&quot;+(i+1)+&quot;个名字：&quot;); //接收控制台录入的姓名字符串 students[i]=sc.next(); &#125; &#125; /** * 2.总览全班同学姓名 * */ public static void printStudentName(String[] students)&#123; //遍历数组，得到每个同学的姓名 for(int i=0;i&lt;students.length;i++)&#123; String name = students[i]; //打印同学姓名 System.out.println(&quot;第&quot;+(i+1)+&quot;个学生姓名：&quot;+name); &#125; &#125; /* * 3.随机点名其中一人 */ public static String randomStudentName(String[] students)&#123; //根据数组长度，获取随机索引 int index = new Random().nextInt(students.length); //通过随机索引从数组中获取姓名 String name = students[index]; //返回随机点到的姓名 return name; &#125; public static void main(String[] arg)&#123; System.out.println(&quot;------------随机点名器------------&quot;); String[] students = new String[3]; /* * 1.储存全班同学姓名 */ addStudentName(students); /* * 2.总览全班同学姓名 */ printStudentName(students); /* * 3.随机点名其中一人 */ String randomName=randomStudentName(students); System.out.println(&quot;被点到名的同学是：&quot;+randomName); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发入门问题及解决方案]]></title>
    <url>%2F2019%2F01%2F22%2FJava%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[JDK的安装错误及解决方案一开始把JDK安装到C盘，在C盘的安装目录下bin目录下编写第一个hello world程序的时候出现以下错误： 文件不能正常保存，需要提供管理员身份。 找不到类，需要创建的类和文件名保持一致 后缀名错误，需要把后缀名显示出来 进行编译是出错 解决方案:在C盘编写代码的时候，需要提供管理员身份，而且有些功能不能实现，所以建议把JDK安装到D盘。 （PS：不过我在安装开发工具的时候有把JDK安装到了C盘，个人感觉安装在那个盘都可以，只不过在C盘操作命令的时候比较麻烦） 系统环境变量的设置按照教材中的做法认真一点，应该不会出错。也可以自己百度一下看一下教程，大致上都是一样的。 eclipse安装错误及解决方案进入官网进行下载eclipse工具时，出现以下错误： 下载出错 安装出错 解决方案:在官网下载时需要下载的是压缩包而不是exe文件，因为网上大部分的安装教程都是将的压缩包的安装方式（ps:自己也不会其他的安装方式）安装是注意自己的安装包是32位还是64位，因为要和自己一开始安装的jdk进行版本的匹配，不同的可能导致安装出错。自己下载二个版本的eclipse压缩包就行了，一个不行换另一个安装就行了。嘻嘻。 总结错误永远都是有的，不多趟点雷，怎么会长知识呢。吃一垫，长一智。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发入门]]></title>
    <url>%2F2019%2F01%2F19%2FJava%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Java概述java是一门程序设计语言 什么是Java javaSE（标准版）开发普通桌面和商务应用程序 javaEE（企业版）开发企业级应用程序 javaME（小型版）开发电子消费产品和嵌入式设备 Java语言特点 简单性 面向对象性 安全性 跨平台性（ps:一段程序可以在Windows上运行，也可以在Linux上运行） 支持多线程 JDK的使用什么是JDKSUN公司提供的一套java开发环境 Java编辑器 Java运行工具 Java文档生成工具 Java打包工具 安装JDK 百度一下（ps:尽量不要安装在C盘） 第一个Java程序编写Java源文件在JDK安装目录的bin目录下新建文本文档，重命名为HelloWorld.java。然后用记事本打开编写一段Java代码，如下所示： 12345678910class HelloWorld&#123; public stacic void mian(String[] args)&#123; System.out.println(&quot;这是第一个Java程序&quot;); &#125;&#125; 打开命令行窗口快捷键win+r,在运行窗口中输入cmd 进入JDK安装目录的bin目录使用cmd命令cd进入安装JDK目录下的bin目录 编译Java源文件使用javac命令对源文件HelloWorld.java进行编译,会在当前目录下生成HelloWorld.class字节码文件。 javac HelloWorld.java Ps：注意类名和文件名保持一致 运行Java程序使用命令java运行文件 java HelloWorld.java 运行时只要输入java HelloWorld就行 系统环境变量在计算书操作系统中可以定义一系列变量，这些变量可提供操作系统上所有应用程序使用，被称为系统环境变量。 path环境变量path环境变量是系统变量的一种，它用于保存一系列的路径，每个路径之间以分号分隔。当在命令行窗口运行一个可执行文件时，操作系统首先会在当前目录下查找该文件是否存在，如果不存在，会继续在path环境变量中定义的路径下寻找这个文件，如果仍未找到，系统会报错。 classpath环境变量classpath环境变量也用于保存一系列路径，它和path环境变量的查看与配置的方式完全相同。当Java虚拟机需要运行一个类时，会在classpath环境变量中所定义的路径下寻找所需的class文件和类包。 环境变量的设置自行百度 Java的运行机制Java程序运行时，必须经过编译和运行二个步骤。首先将后缀名为.java的源文件进行编译，生成后缀名为.class的字节码文件。然后，Java虚拟机将字节码文件进行解释执行，并将结果显示出来。 java程序是由虚拟机负责 开发工具在实际项目开发过程中，由于使用笔记本编写代码速度慢，且不容易排错，所以程序员很少用它来编写代码。为了提高程序的开发效率，大部分软件开发人员都是使用集成开发工具（IDE）来进行程序开发。 Eclipse概述eclipse是由蓝色巨人开发的一款功能完整且成熟的IDE集成开发环境，它是一个开源的、基于Java的可扩展开发平台，目前最流行的Java语言开发工具之一。 Eclipse的安装与启动 安装eclipse开发工具 启动eclipse开发工具 eclipse工作台 eclipse透视图 Eclipse进行程序开发 创建Java项目 在项目下创建包 创建Java类 编写程序代码 运行程序 总结不要好高骛远]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[one]]></title>
    <url>%2F2019%2F01%2F18%2Fone%2F</url>
    <content type="text"><![CDATA[佛家说，人有七苦，生、老、病、死、怨憎会、爱离别、求不得，离合既循环，忧喜迭相攻，佛是想说，众生本该洒脱而淡然地接受一切的阴晴圆缺，可惜，我们只是普通人，不是佛。 《一起同过窗》]]></content>
      <tags>
        <tag>优美句子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F16%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>参考文献</tag>
      </tags>
  </entry>
</search>
