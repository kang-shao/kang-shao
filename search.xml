<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IO(输入输出)]]></title>
    <url>%2F2019%2F05%2F26%2FIO-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[大多数应用程序都需要实现与设备之间的数据传输，例如键盘可以输入数据，显示器可以显示程序运行的结果等。在Java中，将这种通过不同输入输出设备(键盘、内存、显示器、网络等)之间的数据传输抽象表述为“流”，程序允许通过流的方式与输入输出设备进行数据传输。Java中的“流”都位于java.io包中，称为IO(输入输出)流。 IO流有很多种，按照操作数据不同，可以分为字节流和字符流，按照数据传输方向的不同又可分为输入流和输出流，程序从输入流中读取数据，向输出流中写入数据。在IO包中，字节流的输入输出流分别用java.io.InputStream和java.io.OutputStream表示，字符流的输入输出流分别用java.io.Reader和java.io.Writer表示，具体分类如下图所示。 字节流字节流概念在计算机中，无论是文本、图片、音频还是视频，所有文件都是以二进制(字节)形式存在的，IO流中针对字节输入输出提供了一系列的流，统称为字节流。字节流是程序中最常见的流，根据数据的传输方向可将其分为字节输入流和字节输出流。在JDK中，提供了二个抽象类InputStream和OutputStream，它们是字节流的顶级父类，所有的字节输入流都继承自InputStrem，所有的字节输出流都继承自OutputStream。为了方便理解，可以把InputStream和OutputStream比作两根“水管”，如下图所示。 上图中，InputStream被看成一个输入管道，OutputStream被看成一个输出管道，数据通过InputStream从源设备输入到程序，通过OutputStream从程序输出到目标设备，从而实现数据的传输。由此可见，Io流中的输入输出都是相对于程序而言。 在JDK中，InputStream和OutputStream提供了一系列与读写数据相关的方法，接下来了解一下InputStream的常用方法，如下图所示。 上图列举了InputStream的4个常用方法。前三个read()方法都是用来读数据的，其中第一个read()方法是从输入流中逐个读入字节，而第2个和第3个read()方法则将若干字节以字节数组的形式一次性读入，从而提高读数据的效率。在进行IO流操作时，当前IO流会占用一定的内存，由于系统资源宝贵，因此，在IO操作结束后，应该调用close()方法关闭流，从而释放当前IO流所占的系统资源。 与InputStream对应的是OutputStream。OutputStream是用于写数据的，因此OutputStream提供了一些与写数据有关的方法，如下图所示。 上图中列举了OutputStream类的5个常用方法。前3个是重载的write()方法，都用于向输出流写入字节。其中，第一个方法逐个写入字节，后两个方法是将若干个字节以字节数组的形式一次性写入，从而提高写数据的效率。flush()方法用于将来当前输出流缓冲区(通常是字节数组)中数据强制写入目标设备，此过程称为刷新。close()方法是用来关闭流并释放与当前IO流相关的系统资源。 InputStream和OutputStream这两个类虽然提供了一系列和读写数据有关的方法，但是这两个类是抽象类，不能被实例化。因此，针对不同功能，InputStream和OutputStream提供了不同的子类，这些子类形成了一个体系结构，如下图所示。 上图中可以看出，InputStream和OutputStream的子类有很多是大致对应的，比如，ByteArrayInputStream和ByteArrayOutputStream、FileInputStream和FileOutputStream等。图中所列出的IO流都是程序中很常见的，接下来将逐步为读者讲解这些流的具体用法。 字节流读写文件由于计算机中的数据基本保存在硬盘的文件中，因此操作文件中的数据是一种很常见的操作。在操作文件时，最常见的就是从文件中读取数据并将数据写入文件，即文件的读写。针对文件的读写JDK专门提供了二个类，分别是FileInputStream和FileOutputStream。 FileInputStream是InputStream的子类，它是操作文件的字节输入流，专门用于读取文件中的数据。由于从文件读取数据是重复的操作，因此需要通过循环语句来实现数据的持续读取。 接下来通过一个案例来实现字节流对文件数据的读取。首先在Eclipse项目的根目录下创建一个文本文件test.txt，在文件中输入内容“itcast”并保存。然后创建一个读取文本文件的类，具体代码如下图所示。 上图中创建的字节流FileInputStream通过read()方法将当前项目的文件”test.txt”中数据读取并打印。从上图的运行结果可以看出，结果分别为104、101、108、108、111。通常情况下读取文件应该输出字符，这里之所以输出数字是因为硬盘上的文件是以字节形式存在的。在”test.txt”文件中，字符‘h’、‘e’、‘l’、‘l’、‘o’各占一个字节，因此，最终结果显示的就是文件“test.txt”文件中的5个字节所对应的十进制数。 需要注意的是，在读取文件数据时，必须保证文件在相应目录存在并且是可读的，否则会抛出文件找不到的异常FileNotFoundException。 与FileInputStream对应的是FileOutputStream是OutputStream的子类，它是操作文件的字节输出流，专门用于数据写入文件。接下来通过一个案例来演示如何将数据写入文件，如下图所示。 程序运行后，会在项目当前目录下生成一个新的文本文件example.txt(运行程序后，该文件可能不会立即显示在项目目录下，此时使用鼠标右键单击项目，在弹出的窗口中，单击[refresh]，在项目进行刷新即可)，打开文件看到上图所示结果。 从运行结果可以看出，通过FileOutStream写数据时，自动创建了文件example.txt，并将数据写入文件。需要注意的是，如果通过FileOutputStream向一个已经存在的文件中写入数据，那么该文件中的数据首先会被清空，在写入新的数据。若希望在已存在的文件内容之后追加新内容，则可使用FileOutputStream的构造函数FIleOutputStream(String fileName,boolean append)来创建文件输出流对象，并把append参数设置为true。接下来通过一个案例来演示如何将数据追加到文件末尾，如下图所示。 从上图可以看出，程序通过字节输出流对象向文件“example.txt”写入“hello”后，并没有将文件之前的数据清空，而是将新写入的数据追加到了文件的末尾。 由于IO流在进行数据读写操作时会出现异常，为了代码的简洁，在上面的程序中使用了throws关键字将异常抛出。然而一旦遇到IO异常，IO流的close()方法将无法得到执行，流对象所占用的系统资源将得不到释放，因此，为了保证IO流的close()方法必须执行，通常将关闭流操作写在finally代码块中，具体代码如下。 12345678910111213finally&#123; try &#123; if (in!=null) &#123; //如果in不为空，关闭输入流 in.close(); &#125; &#125; catch (Exception e) &#123; if (out!=null) &#123; //如果out不为空，关闭输出流 out.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 文件的拷贝在应用程序中，IO流通常都是成对出现的，即输入流和输出流一起使用。例如文件的拷贝就需要通过输入流来读取文件中的数据，通过输出流将数据写入文件。接下来通过一个案例来演示如何进行文件的内容的拷贝。 首先在当前项目目录下创建文件夹source和target(右键单击项目名称–&gt;[new]–&gt;[folder]),然后在source文件夹中存放一个“love.mp3”文件，拷贝文件的代码如下图所示。 程序运行结束后，刷新并打开target文件夹，发现source文件夹中的“love.mp3”文件被成功拷贝到了target文件夹，如上图所示。 上图中实现了mp3文件的拷贝。在拷贝的过程中，通过while循环将字节逐个进行拷贝。每循环一次，就通过FileInputStream的read()方法读取一个字节，并通过FileOutputStream的write()方法将该字节写入指定文件，循环往复，直到len的值为-1，表示读取到了文件的末尾，结束循环，完成文件的拷贝。程序运行结束以后，会在命令行窗口打印拷贝mp3文件消耗的时间，如上图所示。 上图可以看出，程序拷贝mp3文件共消耗了98302毫秒。在拷贝文件时，由于计算机性能各方面原因，会导致拷贝文件所消耗的时间不确定，因此每次运行程序结果未必相同。 需要注意的是，上图中在定义文件路径使用了”\“。这是因为在Windows中目录符号为反斜线”\”,但反斜线”\”在Java中是特殊字符，表示转义符，所以在使用反斜线”\”时，前面应该再添加一个反斜线，即为”\“。除此之外，目录符号也可以用正斜线”/“来表示，如”source/love.mp3”。 字节流的缓冲区上小节虽然实现了文件的拷贝，但是一个字节一个字节地读写，需要频繁地操作文件，效率非常低。当通过流的方式拷贝文件时，为了提高效率也可以定义定义一个字节数组作为缓冲区。当拷贝文件时，可以一次性读取多个字节的数据，并保存在字节数组中，然后将字节数组中的数据一次性写入文件。接下来学习如何使用缓冲区拷贝文件，如下图所示。 上图实现了mp3文件的拷贝。在拷贝过程中，使用while循环语句逐渐实现字节文件的拷贝，没循环一次，就从文件读取若干字节填充字节数组，并通过变量len记住读入数组的字节数，然后从数组的第一个字节开始，将len个字节依次写入文件。往复循环，当len值为-1，说明已读到了文件末尾，循环会结束，整个拷贝过程结束了。最终程序会将整个文件拷贝到目标文件夹，并将拷贝过程消耗的时间打印出来，如上图所示。 通过二次拷贝文件，可以看出拷贝文件消耗的时间明显减少了，这说明使用缓冲区读写文件可以有效地提高程序的效率。程序中的缓冲区就是一块内存，该内存主要用于存放暂时输入输出的数据，由于使用缓冲区减少了对文件的操作次数，所以可以提高读写数据的效率。 字节缓冲流在IO包中提供了二个带缓冲的字节流，分别是BufferedInputStream和BufferedOutputStream类型的参数作为对象，在读写数据提供了缓冲功能。应用程序、缓冲区和底层字节流之间的关系如下图所示。 上图可以看出，应用程序是通过缓冲流来完成数据读写的，而缓冲区又是通过底层的字节流与设备进行关联的。接下来通过一个案例来学习BufferedInputStream和BufferedOutputStream这两个流的用法。 首先需要在Eclipse的项目目录下创建一个名称为test.txt的文件，并在该文件中写入内容；然后创建一个使用字节缓冲区拷贝该文件的类，如下图所示。 上图中创建了BufferedInputStream和BufferedOutputStream两个缓冲对象，这两个流内部定义了一个大小为10056字节数组。当调用read()或者write()方法读写数据时，首先将读写的数据存入定义好的字节数组，然后将字节数组的数据一次性读写到文件中。这种方法与字节流的缓冲区类似，都对数据进行了缓冲，从而有效地提高了数据的读写效率。 字符流字符流定义及基本用法InputStream类和OutputStream类在读写文件时操作的都是字节，如果希望在程序中操作字符，使用这两个类就不太方便了，为此JDK提供了字符流。同字节流一样，字符流也有两个抽象的顶级父类，分别是Reader和Writer。其中，Reader是字符输入流，用于从某个源设备读取字符。Writer是字符输出流，用于向某个目标设备写入字符。Reader和Writer的一些常用子类，如下图所示。 从下图可以看出，字符流的继承关系与字节流的继承关系有些类似，很多子类都是成对(输入流和输出流)出现的。其中，FileReader和FileWriter用于读写文件BufferedReader和BufferedWriter是具有缓冲功能的流，使他们可以提高读写效率。 字符流操作文件在程序开发中，经常需要对文本文件的内容进行读取，如果想从文件中直接读取字符，便可以使用字符输入流FileReader，通过此流可以从关联的文件中读取一个或一组字符。接下来通过一个案例来学习如何使用FileReader读取文件中的字符。 首先在项目当前目录下新建文本文件”test.txt”并在其中输入字符”hello”，然后创建一个使用字符输入流FileReader读取文件中字符的类，如下图所示。 上图实现了读取文件字符的功能。首先创建一个FileReader对象与文件相连，然后通过while循环每次从文件读取一个字符并打印，这样便实现了FileReader读文件字符的操作。需要注意的是，字符输入流的read()方法返回的是int类型的值，如果想要获得字符就需要进行强制类型转化，上图中，第12行就是将变量ch转为char类型再打印。 上图讲解了如何使用FileReader读取文件中的字符，如果要向文件中写入字符就需要使用FileWriter类，该类是Writer的一个子类。接下来通过一个案例来学习如何使用FileWriter将字符写入文件，如下图所示。 程序运行结束后，会在当前目录下生成一个名称为”writer.txt”的文件，打开此文件会看到上图的内容。 FileWriter同FileOutputStream一样，如果指定的文件不存在，就会先创建文件，在写入数据，如果文件存在，则会首先清空文件中的内容，再进行写入。如果想要在文件末尾追加数据，同样需要调用重载的构造方法，现将上图中第8行代码进行修改。 1FileWriter writer= new FileWriter(&quot;writer.txt&quot;,true); 修改后，再次运行程序，即可实现在文件中追加内容的效果。 通过学习，我们已经了解到包装流可以通过对一个已存在的流进行包装来实现数据读写功能，利用包装流可以有效地提高读写数据的效率。字符流提供了带缓冲区的包装流，分别是BufferedReader和BufferedWriter。其中，BufferedReader用于对字符输入流进行包装，BufferedReader中有一个重要的方法readLine()，该方法用于一次性读取一行文本。接下来通过一个案例来学习如何使用二个包装流实现文件的拷贝，如下图所示。 上图中，使用了输入输出缓冲区对象，并通过一个while循环实现了文本文件的拷贝。在拷贝过程中，每次循环都使用readLine()方法读取文件的一行，然后通过write()方法写入目标文件。其中，readLine()方法会逐个读取字符，当读到回车符’\r’或者换行符’\n’时会将读到的字符作为一行内容返回。 需要注意的是，由于字符缓冲流内部使用了缓冲区，在循环中调用BufferedWriter和write()方法写入字符时，这些字符会首先被写入缓冲区，当缓冲区写满时或调用close()方法时，缓冲区中的字符才会被写入目标文件。因此在循环结束时一定要调用close()方法，否则极有可能会导致部分存在缓冲区中的数据没有被写入目标文件。 转换流IO流可以分为字节流和字符流，有时字节流和字符流之间也需要进行转换。在JDK中提供了二个类可以将字节流转换为字符流，他们分别是InputStreamReader和OutputStreamWriter。 InputStreamReader是Reader的子类，它可以将一个字节输入流转换成字符输入流，方便直接读取字符。OutputStreamWriter是Writer的子类，它可以将一个字节输出流转换成字符输出流，方便直接写入字符。通过转换流进行数据读写的过程如下图所示。 接下来通过一个案例来学习如何将字节流转为字符流。为了提高读写效率，可以通过BufferedWriter和BufferedReader来实现转换工作，具体如下图所示。 上图实现了字节流和字符流之间的转换，将字节流转换为字符流，从而实现直接对字符的读写。需要注意的是，在使用转换流时，只能针对操作文本的字节流进行转换，如果字节流操作的是一张图片，此时转换为字符流就会造成数据丢失。 File类IO流可以对文件的内容进行读写操作，在应用程序中还经常对文件本身进行一些常规的操作，例如创建一个文件、删除或者重命名某个文件、判断硬盘上某个文件是否存在、查询文件最后的修改时间等。针对文件的这类操作，JDK中提供了一个File类，该类封装了一个路径，并提供了一系列的方法用于操作该路径所指向的文件。 File类的常用方法File类用于封装一个路径，这个路径可以是从系统盘符开始的绝对路径，如”D:\file\a.txt”，也可以是相对于当前目录而言的相对路径，如”src\hello.java”。File类内部封装的路径可以指向一个文件，也可以指向一个目录，在File类中提供了针对这些文件或目录的一些常规操作，接下来首先介绍一下File类常用的构造方法。 上图列出了File类的3个构造方法。通常来讲，如果程序只处理一个目录或文件，并且知道该目录或文件的路径，使用第一个构造方法方便。如果程序处理的是一个公共目录中的若干子目录或文件，那么使用第2个或者第3个构造方法会更方便。 File类中提供了一系列方法，用于操作其内部封装的路径指向的文件或者目录，例如根据判断文件是否存在、创建、删除文件\目录等。接下来介绍一下File类常用的构造方法，如下图所示。 上图中列出了File类的一系列常用方法，上图仅仅通过文字对File类的方法进行介绍，接下来通过一个案例来演示File类的常用方法。 调用File类的一系列方法，获取到了文件的名称、绝对路径、相对路径、文件是否可读等信息，最后通过delete()方法将文件删除。 遍历目录下的文件File类中有一个list()方法，该方法用于遍历某个指定目录下的所有文件的名称，接下来通过一个案例演示一下list()方法的用法。 上图中创建了一个File对象，并指定了一个路径，通过调用File的isDirctory()方法判断路径指向的是否存在的目录，如果存在就调用list()方法，获取一个String类型的数组names，数组中包括这个目录下所有文件的文件名。然后通过循环遍历数组names，依次打印出每个文件名。 上图实现了遍历一个目录下的所有文件的功能，然而有时程序只是需要得到指定类型的文件，如获取指定目录下的所有的”.java”文件。针对这种需求，FIle类中提供了一个重载的list(FilenameFilter filter)方法，该方法接收一个FilenameFilter类型的参数。FilenameFilter是一个接口，被称作文件过滤器FilenameFilter，并在accept()方法中做出判断，从而获得指定类型的文件。 为了更好理解文件过滤的原理，接下来分步骤分析list(FilenameFilter filter)方法的工作原理。 调用list()方法传入FilenameFilter文件过滤器对象。 取出当前File对象所代表目录下的所有子目录和文件。 对于每一个子目录或文件，都会调用文件过滤器对象的accept(File dir,String name)方法，并把代表当前目录的File对象以及这个子目录或文件的名字作为参数dir和name传递给方法。 如果accept()方法返回true，就将当前遍历的这个子目录或文件添加到数组中，如果返回false，则不添加。 接下来通过一个案例来演示如何遍历指定目录下所有扩展名为”.txt”的文件，如下图所示。 上图中定义了FilenameFilter文件过滤器对象filter，并且实现了accept()方法。在accept()方法中，对当前正在遍历的currFile对象进行判断，只有当currFile对象代表文件，并且扩展名为”.txt”时，才返回true。在调用File对象的list()方法时，将filter过滤器对象传入，就得到了包含了所有”.txt”文件名字的字符串数组。 前面的例子演示的都是遍历目录下文件的文件名，有时候在一个目录下，除了文件，还有子目录，如果想要得到所有子目录下的File类型对象，list()方法显然不能满足要求，这是需要使用File类提供的另一个方法listFiles()。listFiles()方法返回一个File对象数组，当对数组中的元素进行遍历时，如果元素中还有子目录需要遍历，则需要使用递归。接下来通过一个案例来实现指定目录下的文件，如下图所示。 上图中定义了一个静态方法fileDir()，该方法接收一个目标的File对象。在方法中，首先通过调用listFiles()方法把该目录下所有子目录和文件存到一个File类型的数组files中，接着遍历数组files，并且对当前遍历的File对象进行判断。如果是目录就重新调用fileDir()方法进行递归，如果是文件就直接打印输出文件的路径，这样该目录下所有文件就被成功遍历出来。 删除文件及目录在操作文件时，经常需要删除一个目录下的某个文件或者删除整个目录，这是读者可以使用File类的delete()方法。接下来通过一个案例来演示如何使用delete()方法删除文件。 上图中运行结果中输出了false，这说明删除文件失败了，因为File类的delete()方法只能删除一个指定的文件，假如File对象代表目录，并且目录下包含子目录和文件，则File类的delete()方法不允许对这个目录直接删除。在这种情况下，需要通过递归的方式将整个目录以及其中的文件全部删除。 上图中定义了一个删除目录的静态方法deleteDir()来接收一个类型的参数。在这个方法中调用listFiles()方法把目录下所有的子目录和文件保存到一个File类型的数组files中，然后遍历files，如果是目录就重新调用deleteDir()方法进行递归，如果是文件就直接调用File的delete()方法删除。当删除完一个目录下的所有文件后，在删除当前这个目录，这样便从里层到外层递归地删除了整个目录。 需要注意的是，在Java中删除目录是从虚拟机直接删除不走回收站，文件一旦删除就无法恢复，因此在进行删除操作的时候需要格外小心。 本章小结保存书店每日交易记录程序设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180Books.javapackage xxgc.wlw.wk71;public class Books &#123; int id; String name; //图书名称 double price; //图书单价 int number; //图书数量 double money; //总价 String Publish; //出版社 public Books(int id,String name,double price,int number,double money,String Publish)&#123; this.id=id; this.name=name; this.price=price; this.number=number; this.money=money; this.Publish=Publish; &#125; public String toString()&#123; String message=&quot;图书编号:&quot;+id+&quot; 图书名称: &quot;+name+&quot; 出版社: &quot;+Publish+&quot; 单价: &quot;+price+&quot; 库存数量: &quot;+number; return message; &#125; public void setNumber(int number)&#123; this.number=number; &#125;&#125;RecordBooksOrder.javapackage xxgc.wlw.wk71;import java.util.ArrayList;import java.util.Scanner;public class RecordBooksOrder &#123; static ArrayList&lt;Books&gt; booksList = new ArrayList&lt;Books&gt;();//创建书架 @SuppressWarnings(&quot;resource&quot;) public static void main(String[] args) &#123; init();//初始化书架 //将书架上所有图书信息打印出来 for (int i = 0; i &lt; booksList.size(); i++) &#123; System.out.println(booksList.get(i)); &#125; while(true)&#123; //获取控制台输入的信息 Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入图书编号:&quot;); int bookId = scan.nextInt(); Books stockBooks = getBooksById(bookId); if(stockBooks!=null)&#123;//判断是否存在此图书 System.out.println(&quot;当前图书信息:&quot;+stockBooks); System.out.println(&quot;请输入购买数量:&quot;); int bookNumber = scan.nextInt(); if(bookNumber&lt;=stockBooks.number)&#123;//判断库存是否足够 //将输入信息封装成Books对象 Books books = new Books(stockBooks.id, stockBooks.name, stockBooks.price, stockBooks.number, stockBooks.money, stockBooks.Publish); FileUtil.saveBooks(books);//将本条数据保存至本地文件 //修改库存 stockBooks.setNumber(stockBooks.number-bookNumber); &#125;else &#123; System.out.println(&quot;库存不足!&quot;); &#125; &#125;else &#123; System.out.println(&quot;图书编号输入错误!&quot;); &#125; &#125; &#125; //初始化书架上图书的信息 将图书放到书架上 private static void init() &#123; Books goods1 = new Books(101, &quot;Java编程入门&quot;, 44.50, 100, 4450.00, &quot;清华大学出版社&quot;); Books goods2 = new Books(102, &quot;Java编程基础&quot;, 108.00, 50, 5400.00, &quot;机械工业出版社&quot;); Books goods3 = new Books(103, &quot;Java编程讲义&quot;, 99.00, 100, 9900.00, &quot;电子工业出版社&quot;); booksList.add(goods1); booksList.add(goods2); booksList.add(goods3); &#125; //根据输入的图书编号查找图书信息 循环遍历书架中图书信息，找到图书编号相等的取出 private static Books getBooksById(int bookId) &#123; for (int i = 0; i &lt; booksList.size(); i++) &#123; Books thisBooks = booksList.get(i); if(bookId==thisBooks.id)&#123; return thisBooks; &#125; &#125; return null; &#125;&#125;FileUtil.javapackage xxgc.wlw.wk71;import java.io.*;import java.util.*;import java.text.*;public class FileUtil &#123; public static final String SEPARATE_FIELD = &quot;,&quot;; public static final String SEPARATE_LINE = &quot;\r\n&quot;; //保存图书信息 public static void saveBooks(Books books)&#123; //判断本地是否存在此文件 Date date = new Date(); DateFormat format = new SimpleDateFormat(&quot;yyyyMMdd&quot;);//定义日期格式 String name = &quot;销售记录&quot;+format.format(date)+&quot;.csv&quot;;//拼接文件名 InputStream in = null; try &#123; in = new FileInputStream(name);//判断本地是否存在此文件 if(in!=null)&#123; in.close();//关闭输入流 createFile(name,false,books); //存在文件，采取修改文件方式 &#125; &#125; catch (FileNotFoundException e) &#123; createFile(name,false,books);//不存在文件，采取新建文件新文件方式 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /* * 将图书的售出信息保存到本地，可通过label标识来判断是修改文件还是新建文件 * * name文件名 * label文件已存在的标识true:已存在则修改；false:不存在则新建 * books图书信息 */ private static void createFile(String name, boolean label, Books books) &#123; BufferedOutputStream out = null; StringBuffer sbf = new StringBuffer();//拼接内容 try&#123; if(label)&#123;//当已存在当天的文件，则在文件内容后追加 //创建输入流，用于追加文件 out = new BufferedOutputStream(new FileOutputStream(name,true)); &#125;else &#123;//不存在当天文件，则新建文件 //创建输出流，用于保存文件 out = new BufferedOutputStream(new FileOutputStream(name)); String[] fieldSort = new String[]&#123;&quot;图书编号&quot;,&quot;图书名称&quot;,&quot;购买数量&quot;,&quot;单价&quot;,&quot;总价&quot;,&quot;出版社&quot;&#125;; //创建表头 for (String fieldKye : fieldSort) &#123; //新建时，将表头存入本地文件 sbf.append(fieldKye).append(SEPARATE_FIELD); &#125; &#125; sbf.append(SEPARATE_LINE);//追加换行符 sbf.append(books.id).append(SEPARATE_FIELD); sbf.append(books.name).append(SEPARATE_FIELD); sbf.append(books.number).append(SEPARATE_FIELD); sbf.append((double)books.price).append(SEPARATE_FIELD); sbf.append((double)books.money).append(SEPARATE_FIELD); sbf.append(books.Publish).append(SEPARATE_FIELD); String str = sbf.toString(); byte[] b=str.getBytes(); for (int i = 0; i &lt; b.length; i++) &#123; out.write(b[i]); //将内容写入本地文件 &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; try &#123; if(out !=null) out.close();//关闭输入流 &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; &#125;&#125; 模拟笔记本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package xxgc.wlw.wk72;import java.io.*;import java.util.*;public class Notepad &#123; private static String filePathString; private static String messageString = &quot;&quot;; public static void main(String[] args) throws Exception &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;--1.新建文件 2.打开文件 3.修改文件 4.保存 5.退出--&quot;); while (true) &#123; System.out.print(&quot;请输入操作指令:&quot;); int command = scanner.nextInt(); switch (command) &#123; case 1: createFile(); //1.新建文件 break; case 2: openFile(); //2.打开文件 break; case 3: editFile(); //3.修改文件 break; case 4: saveFile(); //4.保存 break; case 5: exit(); //5.退出 break; default: System.out.println(&quot;您输入的指令错误！&quot;); break; &#125; &#125; &#125; /* * 退出 * */ private static void exit() &#123; System.out.println(&quot;您已退出系统，谢谢使用！&quot;); System.exit(0); &#125; /* * 保存 新建文件存在用户输入的路径 打开的文件将原文件覆盖 * */ private static void saveFile()throws IOException &#123; Scanner scanner = new Scanner(System.in); FileWriter out = null; if (filePathString!=null) &#123; //文件是由&quot;打开&quot;载入的 out=new FileWriter(filePathString); //将原文件覆盖 &#125; else &#123;//新建的文件 System.out.print(&quot;请输入文件保存的绝对路径:&quot;); String pathString = scanner.next(); //获取文件保存的路径 filePathString = pathString; //将输入路径中大写字母替换成小写字母后判断是不是文本格式 if (!filePathString.toLowerCase().endsWith(&quot;.txt&quot;)) &#123; filePathString += &quot;.txt&quot;; &#125; out = new FileWriter(filePathString);//构造输出流 &#125; out.write(messageString); //写入暂存的内容 out.close(); //关闭输出流 messageString = &quot;&quot;; //修改文件前现将写入内容置空 filePathString = null; //将文件路径至null &#125; /* * 修改文件内容 通过字符串替换的形式 * */ private static void editFile() &#123; if (messageString == &quot;&quot; &amp;&amp; filePathString == null) &#123; System.out.println(&quot;请先新建文件或者打开文件&quot;); return; &#125; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入要修改的内容(以\&quot;修改的目标文字:修改后的文字\&quot;格式),&quot;+&quot;停止修改请输入\&quot;stop\&quot;:&quot;); String inputMessageString = &quot;&quot;; while (!inputMessageString.equals(&quot;stop&quot;)) &#123;//当输入stop时，停止修改 inputMessageString = scanner.nextLine(); if (inputMessageString!=null&amp;&amp;inputMessageString.length()&gt;0) &#123; //将输入的文字根据&quot;:&quot;拆分成数组 String[] editMessage = inputMessageString.split(&quot;:&quot;); if (editMessage!=null&amp;&amp;editMessage.length&gt;1) &#123; //根据输入的信息将文件中的内容替换 messageString = messageString.replace(editMessage[0],editMessage[1]); &#125; &#125; &#125; System.out.println(&quot;修改后的内容:&quot;+&quot;\r\n&quot;+messageString); &#125; /* * 打开文件 * */ private static void openFile()throws Exception &#123; messageString = &quot;&quot;;//打开文件将暂存内容清空 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入文件打开的位置:&quot;); filePathString = scanner.next();//获取打开文件的路径 //控制只能输入txt格式的文件路径 if (filePathString != null &amp;&amp; filePathString.endsWith(&quot;.txt&quot;)) &#123; System.out.println(&quot;请选择文本文件！&quot;); return; &#125; FileReader inFileReader = new FileReader(filePathString);//实例化一个FileReader对象 char[] charArray = new char[1024];//缓冲数组 int len = 0; StringBuffer sBuffer = new StringBuffer(); //循环读取，一次性读取一个字符数组 while((len=inFileReader.read(charArray))!=1)&#123; sBuffer.append(charArray); &#125; messageString = sBuffer.toString();//将打开的文件暂存 System.out.println(&quot;打开文件内容:&quot;+&quot;\r\n&quot;+messageString); inFileReader.close();//释放资源 &#125; /* * 新建文件 从控制台获取内容 * */ private static void createFile() &#123; messageString = &quot;&quot;; //新建文件时，暂存文件内容清空 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入内容，停止编写请输入\&quot;stop\&quot;:&quot;);//提示 StringBuffer stb = new StringBuffer();//用于后期输入内容的拼接 String inputMessage=&quot;&quot;; while (!inputMessage.equals(&quot;stop&quot;)) &#123;//当输入&quot;stop&quot;时，停止输入 if (stb.length()&gt;0) &#123; stb.append(&quot;\r\n&quot;); //追加换行符 &#125; stb.append(inputMessage); //拼接输入信息 inputMessage = scanner.nextLine(); //获取输入信息 &#125; messageString = stb.toString();//将输入内容暂存 &#125;&#125; 模拟文件管理器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211DocumentManager.javapackage io73;import java.io.File;import java.util.ArrayList;import java.util.Scanner;public class DocumentManager &#123; public static void main(String[] args) throws Exception &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;--1.指定关键字检索文件 2.指定后缀名检索文件 3.复制文件/目录 4.退出--&quot;); while (true) &#123; System.out.println(&quot;请输入指令:&quot;); int command = scanner.nextInt(); switch (command) &#123; case 1: searchByKeyWorld(); break; case 2: searchBySuffix(); break; case 3: copyDirectory(); break; case 4: exit(); break; default: System.out.println(&quot;你输入的指令错误！&quot;); break; &#125; &#125; &#125; //**************1.指定关键字检索文件******************* private static void searchByKeyWorld() &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入要检索的目录位置：&quot;); String pathString = scanner.next();//从控制台获取路径 File file = new File(pathString); if (!file.exists()||!file.isDirectory()) &#123; System.out.println(pathString+&quot;(不是有效目录)&quot;); return; &#125; System.out.println(&quot;请输入搜索关键字:&quot;); String key = scanner.next();//获取关键字 //在输入目录下获取所有包含关键字的文件路径 ArrayList&lt;String&gt; list = FileUtils.listFile(file,key); for (Object obj : list) &#123; System.out.println(obj);//将路径打印到控制台 &#125; &#125;//****************2.指定后缀名检索文件****************** private static void searchBySuffix() &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入要检索的目录位置：&quot;); String pathString = scanner.next();//从控制台获取路径 File file = new File(pathString); if (!file.exists()||!file.isDirectory()) &#123; System.out.println(pathString+&quot;(不是有效目录)&quot;); return; &#125; System.out.println(&quot;请输入搜索后缀:&quot;); String suffixString = scanner.next(); String[] suffixArrayStrings = suffixString.split(&quot;,&quot;);//获取后缀字符 //在输入目录下获取所有指定后缀名的文件路径 ArrayList&lt;String&gt; list = FileUtils.listFile(file,suffixArrayStrings); for (Object obj : list) &#123; System.out.println(obj);//将路径打印到控制台 &#125; &#125;//***************3.复制目录/文件****************** private static void copyDirectory() throws Exception &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入源目录:&quot;); String srcDirectory = scanner.next();//从控制台获取源路径 File srcFile = new File(srcDirectory); if (!srcFile.exists()||!srcFile.isDirectory()) &#123; System.out.println(&quot;(不是有效目录)&quot;); return; &#125; System.out.println(&quot;请输入目标位置:&quot;); String destDirectoryString = scanner.next();//从控制台获取目标路径 File destFile = new File(destDirectoryString); if (!destFile.exists()||!destFile.isDirectory()) &#123; System.out.println(&quot;(无效位置)&quot;); return; &#125; //将源路径中内容复制到目标路径下 FileUtils.copySrcPathToDestPash(srcFile,destFile); &#125; //************4.退出**************** private static void exit() &#123; System.out.println(&quot;您已退出系统，谢谢使用&quot;); System.exit(0); &#125;&#125;FileUtils.javapackage io73;import java.io.*;import java.util.ArrayList;public class FileUtils &#123; /** * 指定关键字检索文件 * @param file File对象 * @param key关键字 * @return 包含关键字的文件路径 * */ public static ArrayList&lt;String&gt; listFile(File file, final String key) &#123; FilenameFilter filter = new FilenameFilter() &#123; public boolean accept(File dir, String name) &#123; File currFile = new File(dir, name); //如果文件名包含关键字返回true，否则返回false if (currFile.isFile()&amp;&amp;name.contains(key)) &#123; return true; &#125; return false; &#125; &#125;; //递归方式获取规定的路径 ArrayList&lt;String&gt; arrayList = fileDir(file,filter); return arrayList; &#125; /* * 递归方式获取规定的路径 * @param dir File对象 * @param filter 过滤器 * @return 过滤器过滤以后的文件路径 * */ private static ArrayList&lt;String&gt; fileDir(File dir, FilenameFilter filter) &#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); File[] lists = dir.listFiles(filter);//获取过滤后的所有文件数组 for (File list : lists) &#123; //将文件的绝对路径放到集合中 arrayList.add(list.getAbsolutePath()); &#125; File[] files = dir.listFiles(); //获取当前目录下所有文件的数组 for (File file : files) &#123; //遍历所有的子目录和文件 if (file.isDirectory()) &#123; //如果是目录，递归调用fileDir（） ArrayList&lt;String&gt; everyArrayList = fileDir(file, filter); arrayList.addAll(everyArrayList); //将文件夹下的路径添加到集合中 &#125; &#125;//此时的集合中有当前目录下的文件路径，和当前目录的子目录下的文件路径 return arrayList; &#125; /* * 指定后缀名检索文件 * @param file File 对象 * @param suffixArray 后缀名数组 * @return 指定后缀的名的文件路径 * */ public static ArrayList&lt;String&gt; listFile(File file, final String[] suffixArrayStrings) &#123; FilenameFilter filter = new FilenameFilter() &#123; public boolean accept(File dir, String name) &#123; File currFile = new File(dir, name); if (currFile.isFile()) &#123; for (String string : suffixArrayStrings) &#123; if (name.endsWith(&quot;.&quot;+string)) &#123; return true; &#125; &#125; &#125; return false; &#125; &#125;; //递归的方法获取规定的路径 ArrayList&lt;String&gt; arrayList = fileDir(file,filter); return arrayList; &#125; /* * 复制文件/目录 * @param srcFile 源目录 * @param destFile 目标目录 * */ public static void copySrcPathToDestPash(File srcFile, File destFile) throws Exception &#123; File[] files = srcFile.listFiles();//子文件目录 for (int i = 0; i &lt; files.length; i++) &#123; File copiedFile = new File(destFile,files[i].getName()); if (files[i].isDirectory()) &#123;//如果是目录 if (!copiedFile.mkdirs()) &#123;//创建文件夹 System.out.println(&quot;无法创建:&quot;+copiedFile); return; &#125; //调用递归，获取子文件夹下的文件路径 copySrcPathToDestPash(files[i], copiedFile); &#125;else &#123;//复制文件 FileInputStream inputStream = new FileInputStream(files[i]); FileOutputStream outputStream = new FileOutputStream(copiedFile);//获取输出流 byte[] buffer = new byte[1024];//创建缓冲区 int n=0; //循环读取字节 while ((n=inputStream.read(buffer))!=-1) &#123; outputStream.write(buffer,0,n); &#125; inputStream.close();//关闭输入流 outputStream.close();//关闭输出流 &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合类]]></title>
    <url>%2F2019%2F04%2F13%2F%E9%9B%86%E5%90%88%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[学习Java语言，就必须学习如何使用Java的集合类。Java中的集合类就像一个容器，专门用来储存Java类的对象。 集合概述在程序中可以通过数组来保存多个对象，但在某些情况下开发人员无法预先确定需要保存对象的个数，此时数组将不再使用，因为数组的长度不可变。为了在程序中可以保存这些不确定的对象，JDK中提供了一系列特殊的类，这些类可以储存任意类型的对象，并且长度可变，在Java中这些类被统称为集合。集合类都位于Java.util包中，在使用时一定要注意导包问题，否则会出现异常。 集合按照其储存结构可以分为二大类，即单例集合Collection和双列集合Map，这二种集合的特点如下。 Collection:单列集合类的根接口，用于储存一系列符合某种规则的元素，它有二个重要的子接口，分别是List和Set。其中，List的特点是元素有序，可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有ArrayList和LinkedList,Set接口的主要实现类有HashSet和TreeSet。 Map:双列集合类的根接口，用于储存具有键(Key)、值(Value)映射关系的元素，每个元素都包含一对键值，在使用Map集合时可以通过指定的Key找到对应的Value，例如根据一个学生的学号就可以找到对应的学生。Map接口的主要实现类有HashMap和TreeMap。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统的学习，接下来通过一张图来描述整个集合类的继承体系，如下图所示。 上图列出了程序中常用的一些集合类，其中，虚线框里填写的都是接口类型，而实线框填写的都是具体的实现类。 Collection接口Collection是所有单例集合的父接口，因此在Collection中定义了单列集合(List和Set)通过的一些方法，这些方法用于操作所有的单列集合，如下图所示: 图中所列举的方法都来自JavaAPI文档。 List接口List接口简介List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行储存的，在程序中可以通过索引来访问集合中指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下图所示。 上图列举了List集合中的常用方法，所有的List实现类都可以通过调用这些方法来对集合元素进行操作。 ArrayList集合ArrayList是List接口的一个实现类，它是程序中最常见的一种集合。在ArrayList内部封装了一个长度可变的数组对象，当存入的元素超过数组长度时，ArrayList会在内存中分配一个更大的数组来储存这些元素，因此可以将ArrayList集合看作一个长度可变的数组。 ArrayList集合中大部分方法都是从父类Collection和List继承过来的，其中，add()方法和get()方法用于实现元素的存取。接下来通过一个案例来学习ArrayList集合如何存取元素，如下图所示。 首先调用add(Object c)方法向ArrayList集合中添加了4个元素，然后调用size()方法获取集合中的元素个数，最后通过调用ArrayList的get(int index)方法取出指定索引位置的元素。从运行结果可以看出，索引位置为1的元素是集合中的第2个元素，这就说明集合和数组一样，索引的取值范围是从0开始的，最后一个索引是size-1，在访问元素时一定要注意索引不可超出此范围，否则会抛出角标越界异常IndexOutOfBoundsException。 由于ArrayList集合的底层是使用一个数组来保存元素的，在增加或删除指定位置的元素时，会导致创建新的数组，效率比较低，因此不适合做大量的增删操作。但这种数组的结构允许程序通过索引的方式来访问元素，因此使用ArrayList集合查找元素很便捷。 在Eclipse中编译文件时，会得到警告，意思是说在使用ArrayList集合时并没有显示指定集合中存储什么类型的元素，会产生安全隐患，这涉及到泛型安全机制的问题。 在编写程序时，不要忘记导包，否则Eclipse会报出类型不能解决的错误，将鼠标移动到报出错误上并按F2键。 LinkedList集合ArrayList集合在查询元素时速度很快，但在增删元素时效率较低。为了克服这种局限性，可以使用List接口的另一个实现类LinkedList。该集合内部维护了一个双向循环链表，链表中的每一个元素都使用引用的方式来记住它的前一个元素和后一个元素，从而可以将所有的元素彼此连接起来。当插入一个新元素时，只需要修改元素之间的这种引用关系即可，删除一个节点也是如此。正因为这样的储存结构，LinkedList集合对于元素的增删操作具有很高的效率，LinkedList集合添加元素和删除元素的过程如下图所示。 通过上图描述了LinkedList集合新增元素和删除元素的过程。其中，左边为新增一个元素，图中的元素1和元素2在集合中彼此为前后关系，在它们之间增加一个元素时，只需要让元素1记住它后面的元素是新元素，让元素2记住它前面的元素为新元素就可以了。右边为删除元素，想要删除元素1与元素2之间的元素3，只需要让元素1与元素2变成前后关系就可以了。由此可见，LinkedList集合具有增删元素效率高的特点。 针对元素的增删操作，LinkedList集合定义了一些特有的方法，如下图所示。 上图中列出的方法主要是针对集合中的元素进行增加、删除和获取操作。接下来通过案例学习这些方法的使用，如下图所示。 首先在LinkedList集合中存入四个元素，然后通过add(int index,Object o)和addFirst(Object o)方法分别在集合的指定位置和第一位置(索引0位置)插入元素，最后使用remove(int index)和removeFirst()方法将指定位置和集合中的第一个元素移除，这样就完成了元素的增删操作。由此可见，使用LinkedList对元素进行增删操作是非常便捷的。 Iterator接口在程序开发中，经常需要遍历集合中遍历集合中的所有元素。针对这种操作，JDK专门提供了一个接口Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于储存元素，而Iterator主要用于迭代访问(即遍历)Collection中元素，因此Iterator对象也被称为迭代器。 接下来通过一个案例来学习如何使用Iterator迭代集合元素中的元素，如下图所示。 上图演示了Iterator遍历集合的整个过程。当遍历元素时，首先通过调用ArrayList集合的iterator()方法获取迭代器对象，然后使用hasNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出；否则说明已到达了集合末尾，停止遍历元素。需要注意的是，在通过next()方法获取元素时，必须保证要获取的元素存在，否则，会抛出NoSuchElementException异常。 Iterator迭代器对象遍历集合时，内部采用指针的方式来追踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程，如下图所示。 在调用Iterator的next()方法之前，迭代器的索引位于第1个元素之前，不指向任何元素。当第一次调用迭代器的next()方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回。当再次调用next()方法时，迭代器的索引会指向第2个元素并将该元素返回。依次类推，直到hasNext()方法返回false，表示到达了集合的末尾，终止对元素的遍历。 需要特别说明的是，当通过迭代器获取ArrayList集合中的元素时，都会将这些元素当做Object类型来看待，如果想要得到特定类型的元素，则需要进行强制类型转换。 JDK5.0新特性-foreach循环虽然Iterator可以用来遍历集合中的元素，但写法比较繁琐，为了简化书写，从JDK5.0开始提供了foreach循环。foreach循环是一种更加简洁的for循环，也称增强for循环。foreach循环用于遍历数组或集合中的元素，其具体语法格式如下。 123for(容器中元素类型 临时变量 : 容器变量)&#123; 执行语句&#125; 从上面的格式可以看出，与for循环相比，foreach循环不需要获取容器的长度，也不需要根据索引访问容器中的元素，但它会自动遍历容器中的每个元素。接下来通过一个案例对foreach循环进行详细讲解，如下图所示。 从上图可以看出来，foreach循环在遍历集合时语法非常简洁，没有循环条件，也没有迭代语句，所有这些工作都交给虚拟机去执行了，foreach循环的次数是由容器中元素的个数决定的，每次循环时，foreach中都通过变量将当前循环的元素记住，从而将集合中的元素分别打印出来。 foreach循环虽然书写起来很简洁，但在使用时也存在一定局限性。当使用foreach循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改。接下来以一个String类型的数组为例来进行演示，如下图所示: 如上图所示，分别使用foreach循环和普遍for循环去修改数组中的元素。从运行结果可以看出，foreach循环并不能修改数组中元素的值。其中原因是第6行代码中的str=”ddd”只是将临时变量str指定了一个新的字符串，这和数组中元素没有一点关系。而在普通for循环中，是可以通过索引的方式来引用数组中的元素并将其值进行修改的。 在使用Iterator迭代器对集合中的元素进行迭代时，如果调用了集合对象的remove()方式去删除元素后，继续使用迭代器遍历元素，会出现异常。接下来通过一个案例来演示这种异常。假设在一个集合中储存了学校所有学生的姓名，由于一个名为one的学生中途转学，这是就需要在迭代集合时找出该元素并将其删除，如下图所示。 如上图所示在运行时出现了并发修改异常ConcurrentModificationException。这个异常时迭代器对象抛出的，出现异常的原因是集合中删除了元素会导致迭代器预期的迭代次数发生改变，导致迭代器的结果不准确。 为了解决上述问题，可以采用二种方式。 第一种方式:从业务逻辑上只是将姓名为one的学生删除，至于后面还有多少学生并不需要关系，只需找到该学生后跳出循环不再迭代即可，也就是在第13行代码下面增加一个break语句，代码如下。 1234if(&quot;one&quot;.equals(obj))&#123; list.remove(object); break;&#125; 在使用break语句跳出循环以后，由于没有继续使用迭代器对集合中的元素进行迭代，因此，集合中删除元素对程序没有任何影响，就不会再出现异常。 第2种方式:如果需要在集合的迭代期间对集合中的元素进行删除，可以使用迭代器本身的删除方法，将上图中第13行代码替代成iterator.remove()即可解决这个问题，代码如下。 123if (&quot;one&quot;.equals(object)) &#123; iterator.remove(object); &#125; 根据运行结果可以看出，学员one确实被删除了，并且没有出现异常。因此可以得出结论，调用迭代器对象的remove()方法删除元素所导致的迭代次数变化，对于迭代器对象本身来讲是可预知的。 Set接口Set接口集合Set接口和List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。与list接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不会出现重复。 Set接口主要有二个实现类，分别是HashSet和TreeSet。其中，HashSet根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。TreeSet则是以二叉树的方式来存储元素，它可以实现对集合中元素进行排序。 HashSet集合HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的。当向HashSet集合中添加一个对象时，首先会调用该对象的hashCode()方法来计算对象的哈希值，从而确定元素的存储位置。如果此时哈希值相同，再调用对象的equals()方法来确保该位置没有重复元素。Set集合与List集合存取元素的方式都一样，在此不再进行详细的讲解。接下来通过一个案例来演示HashSet集合的用法，如下图所示。 上图中，首先通过add()方法向HashSet集合中依次添加了4个字符串，然后通过Iterator迭代器遍历所有的元素并输出。从打印结果可以看出，取出元素的顺序与添加元素的顺序并不一致，并且重复存入的字符串对象”three”被除去了，只添加了一次。 HashSet集合之所以能确保不出现重复的元素，是因为它再存入元素时做了很多工作。当调用HashSet集合的add()方法存入元素时，首先调用当前存入对象的hashCode()方法获取对象的哈希值，然后根据对象的哈希值计算出一个存储位置。如果该位置上没有元素存在，则直接将元素存入，如果该位置上有元素存在，则会调用equals()方法让当前存入的元素依次和该位置上的元素进行比较。如果返回的结果为false就将该元素存入集合，返回的结果为true则说明有重复元素，就将该元素舍弃。整个存储的流程如下图所示。 根据前面得分析不能看出，当向集合中存入元素时，为了保证HashSet正常工作，要求再存入对象时，重写Object类中的hashCode()和equals()方法。将字符串存入HashSet时，String类已经重写了hashCode()和equals()方法。但是如果将Student对象存入HashSet结果会如何呢。接下来通过一个案例演示，如下图所示。 上图中，向HashSet集合存入3个Student对象，并将这3个对象迭代输出。上图所示的运行结果中出现了二个相同的信息“1:one”，这样的学生信息应该被视为重复元素，不允许同时出现再HashSet集合中。之所以没有去掉这样的重复元素，是因为再定义Student类时没有重写hashCode()和equals()方法。接下来针对上图的Student类进行改写，假设id相同的就是同一个信息，改写代码如下图所示。 上图中，Student类重写了Object类的hashCode()和equals()方法。在hashCode()方法中返回值idString属性的哈希值，在equals()方法中比较对象的idString属性是否相等，并返回结果。当调用HashSet集合的add()方法添加stu3对象时，发现它的哈希值与stu1对象相同，并且stu1.equals(stu3)返回true。HashSet集合认为二个对象相同，因此重复的Student对象被成功去除了。 Map接口Map接口简介在现实生活中，每个人都有唯一的身份证号，通过身份证号可以查询到这个人的信息，这二者是一对一的关系。在应用程序中，如果想要存储这种具有对应关系的数据，则需要使用JDK中提供的Map接口。 Map接口是一种双列集合，它的每个元素都包含一个键对象Key和值对象Value，键和值对象之间存在一种对应关系，称为映射。从Map集合中访问元素时，只要指定了Key，就能找到对应的Value。 为了便于Map接口的学习，首先来了解一下Map接口中定义的一些常用方法，如下图所示。 上图列出了一系列的方法用于操作Map，其中，put(Object key,Object value)和get(Object key)方法分别用于向Map中存入元素和取出元素；containsKey(Object key)和containsValue(Object value)方法分别用于判断Map中是否包含某个指定的键或值；keySet()和value()方法分别用于获取Map中所有的键和值。 HashMap集合HashMap集合是Map接口的一个实现类，它用于存储键值映射关系，但必须保证不出现重复的键。接下来通过一个案例来学习HashMap的用法，如下图所示。 上图中，首先通过Map的put(Object key,Object value)方法向集合中加入3个元素，然后通过Map的get(Object key)方法获取相应的键值。前面已经介绍过Map集合中键具有唯一性，现在向Map集合中存储一个相同的键，结果如下图所示。 上图中可以看出，Map中仍然只有3个元素，只是地4次添加的值”three1”覆盖了原来的值”three”，这也证实了Map中的键必须是唯一的，不能重复，如果存储了相同的键，后存储的值会覆盖原有的值，简而言之就是键相同，值覆盖。 在程序开发中，经常需要取出Map中所有键和值，那么如何遍历Map中所有键值对呢？有二种方式可以实现，第一种方式就是先遍历Map集合中所有的键，在根据键获取相应的值。 接下来就通过演示先遍历Map集合中所有的键，在根据键获取相应的值的方式，如下图所示。 上图中，首先调用Map对象的KeySet()方法，获取存储Map中所有键的Set集合，然后通过Iterator迭代Set集合的每一个元素，即每一个键，最后通过调用Set(String key)的方法，根据键获取对应的值。 Map集合的另外一种遍历方式是先获取集合中的所有的映射关系，然后从映射关系中取出键和值。如下图所示。 上图中，首先调用Map对象的entrySet()方法获得存储在Map中所有映射的Set集合，这个集合中存放了Map.Entry类型的元素(Entry是Map内部接口),每个Map.Entry对象代表Map中的一个键值对，然后迭代Set集合，获得每一个映射对象，并分别调用映射对象的getKey()和getValue()方法获取键和值。 在Map中还提供了一个values()方法，通过这个方法可以直接获取Map中存取所有值的Collection集合。接下来通过案例来演示values()方法的使用，如下图所示。 上图中，通过调用Map的values()方法获取包含Map中所有值的Collection集合，然后迭代出集合中的每一个值。 从上面的例子可以看出，HashMap集合迭代出来元素的顺序和存入的顺序是不一致的。如果想让这二个顺序一致，可以使用Java中提供的LinkedHashMap类，它是HashMap的子类，与LinkedList一样，它也使用双向链表来维护内部元素的关系，使Map元素迭代的顺序与存入的顺序一致。 接下来通过一个案例来学习一下LinkedHashMap的用法，如下图所示。 上图中，首先创建了一个LinkedHashMap集合并存入了3个元素，然后使用迭代器将元素取出。从运行结果可以看出，元素迭代出来的顺序和存入的顺序是一致的。 Properties集合Map接口中还有一个实现类Hashtable，它和HashMap十分相似，区别在于Hashtable是线程安全的。Hashtable存取元素时速度很慢，目前基本上被HashMap类所取代，但Hashtable类还有一个子类Properties，在实际应用中非常重要。 Properties主要用于存储字符串类型的键和值，在实际开发中，经常使用Properties集合来存取应用的配置项。假设有一个文本编辑工具，要求默认背景是红色，字体大小为14px，语言为中文，其配置项如下。 123Backgroup-color = redFont-size = 14pxLanguage = chinese 在程序中可以使用Properties集合对这些配置进行存取，接下来通过一个案例来学习Properties集合的使用，如下图所示。 上图中的Properties类中，针对字符串的存取提供了二个专用的方法:setProperty()和getProperty()。setProperty()方法用于配置项的键和值添加到Properties集合中。在第8行代码中通过调用Properties的propertyNames()方法得到一个包含所有键的Enumeration对象，如何在遍历所有的键时，通过调用getProperty()方法获得键所对应的值。 JDK5.0新特性-泛型通过之前的学习，读者可以了解到集合可以存储任何类型的对象，但是当把一个对象存入集合后，集合会“忘记”这个对象的类型，将该对象从集合中取出时，这个对象的编译类型就变成了Object类型。换句话说，在程序中无法确定一个集合中元素到底是什么类型的。那么在取出元素时，如果进行强制类型转换就很容易出错。接下来通过一个案例演示这种情况，如下图所示。 上图中向List集合存入了3个元素，分别是二个字符串和一个整数。在取出这些元素时，都将他们强制转换为String类型，由于Integer对象无法转换为String类型，因此在程序运行时会出现上图中出现的错误。为了解决这个问题，在Java中引用了“参数化类型(parameterizedtype)”这个概念，即泛型。它可以限定方法操作的数据类型，在定义集合类时，使用“&lt;参数化类型&gt;”的方式指定该类中方法操作的数据类型，具体格式如下。 1ArrayList&lt;参数化类型&gt; list = new ArrayList&lt;参数化类型&gt;(); 接下来对上图代码进行修改，如下所示。 12ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();//创建集合对象并指定泛型为String 上面的写法就限定了ArrayList集合指定只能存储String类型元素，将改写后的程序在Eclipse中编译出错提示，如下图所示。 上图中，程序编译报错的原因是修改后的代码限定了集合元素的数据类型，ArrayList这样的集合只能存储String类型的元素，程序在编译时，编译器检查出Integer类型的元素与List集合的规定类型不匹配，编译不通过。这样就可以在编译时解决错误，避免程序在运行时发生错误。 接下来使用泛型在此修改，如下图所示。 上图中使用泛型规定了ArrayList集合只能存入String类型元素，然后向集合中存入了二个String类型元素，并对这个集合进行遍历，从上图运行结果可以看出，该文件可以正常运行。需要注意的是，在使用泛型后，每次遍历集合元素时，可以指定元素类型为String，而不是Object，这样就避免了在程序中进行强制类型转换。 本章小结模拟KTV点歌系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201package KTV61;import java.util.ArrayList;import java.util.Scanner;public class KTVByArrayList &#123; /** * @param args */ public static void main(String[] args) &#123; System.out.println(&quot;----------欢迎来到点歌系统----------&quot;); System.out.println(&quot;0.添加歌曲至列表&quot;); System.out.println(&quot;1.将歌曲置顶&quot;); System.out.println(&quot;2.将歌曲前移一位&quot;); System.out.println(&quot;3.退出&quot;); ArrayList lineUpList = new ArrayList();//创建歌曲列表 addMusicList(lineUpList); //添加一部分歌曲至歌曲列表 while (true) &#123; System.out.print(&quot;请输入要执行的操作序号:&quot;); Scanner scanner = new Scanner(System.in);//接收键盘输入的功能选项序号 //执行序号对应的功能 int command = scanner.nextInt(); switch (command) &#123; case 0://添加歌曲至列表 addMusic(lineUpList); break; case 1://将歌曲置顶 setTop(lineUpList); break; case 2://将歌曲前移一位 setBefore(lineUpList); break; case 3://退出 exit(); break; default: System.out.println(&quot;---------------------------&quot;); System.out.println(&quot;功能选择出错，请输入正确的功能序号！&quot;); break; &#125; System.out.println(&quot;当前歌曲列表:&quot;+lineUpList); &#125; &#125; //退出 private static void exit() &#123; System.out.println(&quot;-------------退出--------------&quot;); System.out.println(&quot;您已退出系统&quot;); System.exit(0); &#125; //执行将歌曲置前一位 private static void setBefore(ArrayList lineUpList) &#123; System.out.println(&quot;请输入要置前的歌曲名称:&quot;); String musicName = new Scanner(System.in).nextLine(); int position = lineUpList.indexOf(musicName);//查找指定歌曲位置 if (position&lt;0) &#123; //判断输入歌曲是否存在 System.out.println(&quot;当前列表中没有输入的歌曲!&quot;); &#125;else if (position==0) &#123;//判断歌曲是否已在第一位 System.out.println(&quot;当前歌曲已在最顶部&quot;); &#125;else &#123; lineUpList.remove(musicName);//移除指定的歌曲 lineUpList.add(position-1,musicName);//将指定的歌曲放到前一位 &#125; System.out.println(&quot;已将歌曲&quot;+musicName+&quot;置前一位&quot;); &#125; //执行将歌曲置顶 private static void setTop(ArrayList lineUpList) &#123; System.out.println(&quot;请输入要置顶的歌曲名称:&quot;); String musicName = new Scanner(System.in).nextLine(); int position = lineUpList.indexOf(musicName);//查找指定歌曲位置 if (position&lt;0) &#123; //判断输入歌曲是否存在 System.out.println(&quot;当前列表中没有输入的歌曲!&quot;); &#125;else &#123; lineUpList.remove(musicName); //移除指定的歌曲 lineUpList.add(0,musicName); //将指定的歌曲放到第一位 &#125; System.out.println(&quot;已将歌曲&quot;+musicName+&quot;置顶&quot;); &#125; //执行添加歌曲 private static void addMusic(ArrayList lineUpList) &#123; System.out.println(&quot;请输入要添加的歌曲名称:&quot;); String musicName = new Scanner(System.in).nextLine(); lineUpList.add(musicName);//添加 歌曲到列表的最后 System.out.println(&quot;已添加歌曲:&quot;+musicName); &#125; //初始化时添加歌曲名称 private static void addMusicList(ArrayList lineUpList) &#123; lineUpList.add(&quot;稻香&quot;); lineUpList.add(&quot;夜曲&quot;); lineUpList.add(&quot;夜的第七章&quot;); lineUpList.add(&quot;听妈妈的话&quot;); lineUpList.add(&quot;龙卷风&quot;); System.out.println(&quot;初始化列表：&quot;+lineUpList); &#125;&#125;package KTV61;import java.util.LinkedList;import java.util.Scanner;public class KTVByLinkedList &#123; public static void main(String[] args) &#123; System.out.println(&quot;----------欢迎来到点歌系统----------&quot;); System.out.println(&quot;0.添加歌曲至列表&quot;); System.out.println(&quot;1.将歌曲置顶&quot;); System.out.println(&quot;2.将歌曲前移一位&quot;); System.out.println(&quot;3.退出&quot;); LinkedList lineUpList = new LinkedList();//创建歌曲列表 addMusicList(lineUpList); //添加一部分歌曲至歌曲列表 while (true) &#123; System.out.print(&quot;请输入要执行的操作序号:&quot;); Scanner scanner = new Scanner(System.in);//接收键盘输入的功能选项序号 //执行序号对应的功能 int command = scanner.nextInt(); switch (command) &#123; case 0://添加歌曲至列表 addMusic(lineUpList); break; case 1://将歌曲置顶 setTop(lineUpList); break; case 2://将歌曲前移一位 setBefore(lineUpList); break; case 3://退出 exit(); break; default: System.out.println(&quot;---------------------------&quot;); System.out.println(&quot;功能选择出错，请输入正确的功能序号！&quot;); break; &#125; System.out.println(&quot;当前歌曲列表:&quot;+lineUpList); &#125; &#125; //退出 private static void exit() &#123; System.out.println(&quot;-------------退出--------------&quot;); System.out.println(&quot;您已退出系统&quot;); System.exit(0); &#125; //执行将歌曲置前一位 private static void setBefore(LinkedList lineUpList) &#123; System.out.println(&quot;请输入要置前的歌曲名称:&quot;); String musicName = new Scanner(System.in).nextLine(); int position = lineUpList.indexOf(musicName);//查找指定歌曲位置 if (position&lt;0) &#123; //判断输入歌曲是否存在 System.out.println(&quot;当前列表中没有输入的歌曲!&quot;); &#125;else if (position==0) &#123;//判断歌曲是否已在第一位 System.out.println(&quot;当前歌曲已在最顶部&quot;); &#125;else &#123; lineUpList.remove(musicName);//移除指定的歌曲 lineUpList.add(position-1,musicName);//将指定的歌曲放到前一位 &#125; System.out.println(&quot;已将歌曲&quot;+musicName+&quot;置前一位&quot;); &#125; //执行将歌曲置顶 private static void setTop(LinkedList lineUpList) &#123; System.out.println(&quot;请输入要置顶的歌曲名称:&quot;); String musicName = new Scanner(System.in).nextLine(); int position = lineUpList.indexOf(musicName);//查找指定歌曲位置 if (position&lt;0) &#123; //判断输入歌曲是否存在 System.out.println(&quot;当前列表中没有输入的歌曲!&quot;); &#125;else &#123; lineUpList.remove(musicName); //移除指定的歌曲 lineUpList.addFirst(musicName); //将指定的歌曲放到第一位 &#125; System.out.println(&quot;已将歌曲&quot;+musicName+&quot;置顶&quot;); &#125; //执行添加歌曲 private static void addMusic(LinkedList lineUpList) &#123; System.out.println(&quot;请输入要添加的歌曲名称:&quot;); String musicName = new Scanner(System.in).nextLine(); lineUpList.addLast(musicName);//添加 歌曲到列表的最后 System.out.println(&quot;已添加歌曲:&quot;+musicName); &#125; //初始化时添加歌曲名称 private static void addMusicList(LinkedList lineUpList) &#123; lineUpList.add(&quot;稻香&quot;); lineUpList.add(&quot;夜曲&quot;); lineUpList.add(&quot;夜的第七章&quot;); lineUpList.add(&quot;听妈妈的话&quot;); lineUpList.add(&quot;龙卷风&quot;); System.out.println(&quot;初始化列表：&quot;+lineUpList); &#125;&#125; 模拟新浪微博用户123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package jihelei71;import java.util.Date;import java.util.HashSet;import java.util.Scanner;public class UserRegister &#123; public static HashSet&lt;User&gt; USER_DATA = new HashSet&lt;User&gt;();//用户数据 public static void main(String[] args) &#123; initData();//初始化人员信息 Scanner scan = new Scanner(System.in); System.out.print(&quot;请输入用户名:&quot;); String userName = scan.nextLine(); //获取用户名 System.out.print(&quot;请输入密码:&quot;); String password = scan.nextLine();//获取密码 System.out.print(&quot;请重复密码:&quot;); String repassword = scan.nextLine(); //获取重复密码 System.out.print(&quot;出生日期:&quot;); String birthday = scan.nextLine(); //获取出生日期 System.out.print(&quot;手机号:&quot;); String telNumber = scan.nextLine(); //获取手机号码 System.out.print(&quot;电子邮箱:&quot;); String email = scan.nextLine(); //获取电子邮箱 //校验用户信息，返回登录状态信息 CheckInfo checkInfo = new CheckInfo(USER_DATA); String result = checkInfo.checkAction(userName,password,repassword,birthday,telNumber,email); System.out.println(&quot;注册结果:&quot;+result); &#125; //初始化数据，创建二个已存在的用户信息 private static void initData() &#123; User user = new User(&quot;张正&quot;,&quot;zz,123&quot;,new Date(),&quot;18810319240&quot;,&quot;kangshao@qq.com&quot;); User user2 = new User(&quot;周琦&quot;,&quot;zq,123&quot;,new Date(),&quot;18610319240&quot;,&quot;shaoye@qq.com&quot;); USER_DATA.add(user); USER_DATA.add(user2); &#125;&#125;package jihelei71;import java.util.Date;//用户信息public class User &#123; private String userName; //用户名 private String password; //密码 private Date birthday; //生日 private String telNumber; //手机号 private String email; //邮箱 public User()&#123; &#125; public User(String userName,String password,Date birthday,String telNumber,String email)&#123; this.userName=userName; this.password=password; this.birthday=birthday; this.telNumber=telNumber; this.email=email; &#125; //重写hashCode与equals方法 public int hashCode()&#123;//重写hashCode方法，以用户名作为是否重复的依据 return userName.hashCode(); &#125; public boolean equals(Object obj)&#123; if (this==obj) &#123;//判断是否是同一个对象 return true; //如果是同一个对象，直接返回true &#125; if (obj==null) &#123; //判断这个对象是否为空 return false; //如果是同一个对象，直接返回false &#125; if (getClass()!=obj.getClass()) &#123; //判断这个对象是否是User类型 return false; //如果不是，直接返回false &#125; User other = (User)obj;//将对象强制为User类型 if(userName==null)&#123; //判断集合中用户名是否为空 if (other.userName!=null) &#123; //判断对象中的用户名是否为空 return false; //集合中用户名为空且对象中用户名不为空，则返回false &#125; &#125;else if (!userName.equals(other.userName)) &#123;//判断用户名是否相同 return false; //如果不同，返回false &#125; return true; &#125;&#125;package jihelei71;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashSet;public class CheckInfo &#123; public static HashSet&lt;User&gt; USER_DATA = new HashSet&lt;User&gt;(); //用户数据 public CheckInfo(HashSet&lt;User&gt; USER_DATA)&#123; this.USER_DATA = USER_DATA; &#125; //效验用户信息，返回登录状态信息 public String checkAction(String userName,String password,String rePassword,String brithday,String phone,String email)&#123; StringBuilder result = new StringBuilder(); //1代表成功 2代表失败 int state = 1; //密码判断 if(!password.equals(rePassword))&#123;//判断密码和重复密码是否相同 result.append(&quot;二次密码不一致!\r\n&quot;); state = 2; &#125; //生日判断 if (brithday.length()!=10) &#123; //字符串长度不为10，则认为格式错误 result.append(&quot;生日格式不正确!\r\n&quot;); state =2; &#125;else &#123; for (int i = 0; i &lt; brithday.length(); i++) &#123; Character thisChar = brithday.charAt(i); if(i==4||i==7)&#123; if (!(thisChar==&apos;-&apos;)) &#123;//验证第4位和第7位是否是符号&quot;-&quot; result.append(&quot;生日格式不正确!\r\n&quot;); state =2; &#125; &#125;else &#123;//验证除了第4位和第7位的字符是否是0~9的数字 if (!(Character.isDigit(thisChar))) &#123; result.append(&quot;生日格式不正确!\r\n&quot;); state =2; &#125; &#125; &#125; &#125;//手机号判断 if (phone.length()!=11) &#123;//判断手机号长度不等于11位则认为此手机号无效 result.append(&quot;手机号码不正确!\r\n&quot;); state =2; //默认有效手机号为13、15、17、18开头的手机号 &#125;else if (!(phone.startsWith(&quot;13&quot;)||phone.startsWith(&quot;15&quot;)||phone.startsWith(&quot;17&quot;)||phone.startsWith(&quot;18&quot;))) &#123; result.append(&quot;手机号码不正确!\r\n&quot;); state =2; &#125; //邮箱注册 if(!email.contains(&quot;@&quot;))&#123; //判断邮箱地址，默认不带@符号的邮箱为无效邮箱 result.append(&quot;邮箱不正确!\r\n&quot;); state =2; &#125; //如果以上信息效验无误，则将新用户加入集合 if (state==1) &#123; //格式化日期返回Date对象 DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date dateBirthday = null; try &#123; dateBirthday = format.parse(brithday); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; User newUser = new User(userName, rePassword, dateBirthday, phone, email); //将用户添加到列表中，同时可根据HashSet判断用户名有没有重复 if (!USER_DATA.add(newUser)) &#123; result.append(&quot;用户重复&quot;); state = 2 ; &#125; if (state == 1) &#123; result.append(&quot;注册成功&quot;); &#125; &#125; return result.toString(); &#125;&#125; 斗地主小游戏之洗牌发牌12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package doudizhu;import java.util.*;public class PokerShuffleCards &#123; //准备花色 public static void main(String[] args) &#123; ArrayList&lt;String&gt; color = new ArrayList&lt;String&gt;(); color.add(&quot;♠&quot;); color.add(&quot;♥&quot;); color.add(&quot;♦&quot;); color.add(&quot;♣&quot;); //准备数字，用ArrayList将纸牌由小到大排序 ArrayList&lt;String&gt; number = new ArrayList&lt;String&gt;(); for (int i = 3; i &lt;= 10; i++) &#123; number.add(i+&quot;&quot;); &#125; number.add(&quot;J&quot;); number.add(&quot;Q&quot;); number.add(&quot;K&quot;); number.add(&quot;A&quot;); number.add(&quot;2&quot;); //定义一个map集合：用来将数字与每一张纸牌相对应 HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); int index = 0;//纸牌编号 for (String thisNumber : number) &#123; //循环纸牌数字 for (String thisColor : color) &#123; //循环纸牌花色 //将花色与数字组合，形成52张牌，并赋予其编号 map.put(index++, thisColor + thisNumber); &#125; &#125; //加入大小王 map.put(index++, &quot;大王&quot;); map.put(index++, &quot;小王&quot;); //创建内容为0~53的数字集合，代表着54张牌 ArrayList&lt;Integer&gt; cards = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt;= 53; i++) &#123; cards.add(i);//此时的cards顺序为0-53 &#125; //洗牌，使用Collections工具类中的shuffle()方法 Collections.shuffle(cards);//此时的cards顺序已被打乱 //创建三个玩家和底牌 ArrayList&lt;Integer&gt; iPlayer = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; iPlayer2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; iPlayer3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; iSecretCards = new ArrayList&lt;Integer&gt;(); //遍历这幅洗好的牌，遍历过程中，将牌发到3个玩家和底牌中 for (int i = 0; i &lt; cards.size(); i++) &#123; if (i&gt;=51) &#123; iSecretCards.add(cards.get(i));//留取3张底牌 &#125;else &#123; if (i%3==0) &#123; iPlayer.add(cards.get(i));//与3取余为0的牌发给玩家1 &#125;else if (i%3==1) &#123; iPlayer2.add(cards.get(i));//与3取余为0的牌发给玩家2 &#125;else &#123; iPlayer3.add(cards.get(i));//其余的牌发给玩家3 &#125; &#125; &#125; //对每个人手中的牌排序，使用Collections工具类中的sort()方法 Collections.sort(iPlayer); Collections.sort(iPlayer2); Collections.sort(iPlayer3); //对应数字形式的每个人手中的牌，定义字符串形式的牌 ArrayList&lt;String&gt; sPlayer = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; sPlayer2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; sPlayer3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; sSecrectCards = new ArrayList&lt;String&gt;(); //循环主键，从map中获取纸牌 for (Integer string : iPlayer) &#123; sPlayer.add(map.get(string)); &#125; for (Integer string : iPlayer2) &#123; sPlayer2.add(map.get(string)); &#125; for (Integer string : iPlayer3) &#123; sPlayer3.add(map.get(string)); &#125; for (Integer string : iSecretCards) &#123; sSecrectCards.add(map.get(string)); &#125; //看牌 System.out.println(&quot;玩家1:&quot;+sPlayer); System.out.println(&quot;玩家2:&quot;+sPlayer2); System.out.println(&quot;玩家3:&quot;+sPlayer3); System.out.println(&quot;底牌:&quot;+sSecrectCards); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaAPI]]></title>
    <url>%2F2019%2F03%2F11%2FJavaAPI%2F</url>
    <content type="text"><![CDATA[API(Application Programming lnterface)指的是应用程序接口。JavaAPI指的就是JDK中提供的的各种功能的Java类。 String类和StringBuffer类在应用程序中经常会用到字符串，所谓字符串就是指一连串的字符，它是由许多单个字符连接而成，如多个英文字母所组成的一个英文单词。字符串中可以包含任意字符，这些字符必须包含在一对双引号””之内，例如”abc”。在Java中定义了String和StringBuffer二个类来封装字符串，并提供了一系列操作字符串的方法，它们都位于java.lang包中，因此不需要导包就可以直接使用。 String类的初始化在操作String类之前，首先需要对String类进行初始化，在Java中可以通过以下二种方式对String类进行初始化，具体如下： 使用字符串常量直接初始化一个String对象，具体代码如下。 String str1 = &quot;abc&quot;; 由于String类比较常用，所以提供了这种简洁的语法，用于创建并初始化String对象。 使用String的构造方法初始化字符串对象，String类构造方法如下： 上图列出了String类的三种构造方法，通过调用不同的参数的构造方法便可完成String类的初始化。 String类的常见操作String类的常用方法如下图所示: 字符串的基本操作 在程序中，需要对字符串进行一些基本操作，如获取字符串长度、获得指定位置的字符等。String类针对每一个操作都提供了对应的方法。具体如下图所示: 如图所示，String类提供的方法可以很方便地获取字符串长度，获取指定位置的字符以及指定字符和字符串的位置。 字符串的转换操作 程序开发中，经常需要对字符串进行转换操作，例如将字符串转换成数组的形式，将字符进行大小写转换等。 使用String类的toCharArray()方法将一个字符串转换为一个字符数组，静态方法valueOf()将一个int类型的整数转为字符串,toUpperCase()方法将字符串中的字符都转为大写。其中，valueOf()方法有很多重载的形式，float、double、char等其他基本类型的数据都可以通过该方法转为String字符串类型。 字符串的替换和去除空格操作 程序开发过程中，用户输入数据时经常会有一些错误和空格，这是可以使用String类的replace()和trim()方法，进行字符串的替换和去除空格操作。 replace()方法用于将字符串中所有与指定字符串匹配字符串的子串替换成另一个字符串，trim()方法用于去除字符串中的空格。需要注意的是该方法只能去除二端的空格，不能去除中间的空格。若想去除字符串中间的空格，则可以调用String类和replace()方法。 字符串的判断操作 操作字符串时，经常需要对字符串进行一些判断，如判断字符串是否以指定的字符串开始、结束，是否包含指定的字符串，字符串为空等。 上图中涉及到的方法都是用于判断字符串的，并且返回值均为boolean类型。其中，equals()方法比较重要，该方法将父类Object中equals()方法进行重写。 在程序中可以通过“==”和equals()二种方式对字符串进行比较，但这两种方式有明显的区别。equals()方法用于比较二个字符串中的字符是否相等，==方法用于比较二个字符串对象的地址是否相同。对于两个字符串对象，当他们的字符内容完全相同时，使用equals判断结果会为true，但使用==判断时，结果一定为false。 123456 String str1 = new String(&quot;abc&quot;);String str2 = new String(&quot;abc&quot;);//结果为false，因为str1和str2是二个对象System.out.println(str1==str2);//结果为true，因为str1和str2字符内容相同System.out.println(str1.equals(str2)); 字符串的截取和分隔 在String类中针对字符串的截取和分隔操作提供了二个方法。其中，substring()方法用于截取字符串的一部分，split()方法可以将字符串按照某个字符进行分隔。 调用了String类中重载的二个substring()方法。在调用substring()方法时，传入了参数4，因为字符串中的字符索引是从0开始的，所以会截取字符串中第5个以及以后的所有字符。第七行代码调用substring()方法时传入二个参数4和6，因为字符串在截取时，只包括开始索引，不包括结束索引，所以会截取第5个和第6个字符。split()方法的用法，该方法会根据指定的符号”,”将字符串分隔成3个部分，并存放到一个String类型的数组当中。 String字符串在获取某个字符时，会用到字符的索引。当访问字符串中的字符时，如果字符索引不存在，则会发生StringIndexOutOfBoundsException(字符串角标越界异常)。 StringBuffer类由于字符串是常量，因此一旦创建，其内容和长度是不可改变的。如果需要对一个字符串进行修改，则只能创建新的字符串。为了便于对字符串进行修改，在JDK中提供了一个StringBuffer类(也称字符串缓冲区)。StringBuffer类和String类最大的区别在于他的内容和长度都是可以改变的。StringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StringBuffer对象。 针对添加和删除字符的操作，StringBuffer类提供了一系列的方法，如下图所示: 实例如下图所示: StringBuffer类有很多方法,其中,append()和insert()方法是最常用的，并且这二个方法有很多重载形式，他们都用于添加字符。不同的是，append()方法始终将这些字符添加到缓冲区的末尾，而insert()方法则可以在指定位置添加字符。另外，delete()方法用于删除指定位置的字符，setCharAt()和replace()方法用于替换指定位置的字符。 StringBuffer类和String类有很多相似之处，初学者在使用时很容易混淆。如下对比二个类的不同： String类表示的字符串是常量，一旦创建后，内容和长度都是无法改变的。而StringBuffer表示字符容器，其内容和长度可以随时修改。在操作字符串时，如果该字符仅用于表示数据类型，则使用String类即可。但是如果需要对字符串中的字符进行增删操作，则使用StringBuffer类。 String类覆盖了Object类的equals()方法，而StringBuffer类没有覆盖Object类的equals()方法，具体如下: String类对象可以用操作符“+”进行连接，而StringBuffer类对象之间不能，具体如下: 1234567String s1 = new &quot;a&quot;;String s2 = new &quot;b&quot;;String s3 = s1 + s2; //合法System.out.println(s3); //打印输出abStringBuffer sb1 = new StringBuffer(&quot;abc&quot;);StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);StringBuffer sb3 =sb1 + sb2;//编译出错 System类与Running类System类System类定义了一些与系统相关的属性和方法，它所提供的属性和方法都是静态的，因此，想要引用这些属性和方法，直接使用System类调用即可。 System类的常用方法如下所示: getProperties()方法 System类的getProperties()方法用于获取当前系统的全部属性，该方法会返回一个Properties对象，其中封装了系统的所有属性。这些属性是以键值对形式存在的。如下是getProperties()方法的使用。 如上实现了获取当前系统属性的功能。首先通过System的getProperties()方法获取了系统属性的Properties集合，然后对Properties集合进行迭代，将所有系统属性的键以及对应的值打印出来。 currentTimeMillis() currentTimeMillis()方法返回一个long类型的值，该值表示当前时间与1970年1月1日0点0分0秒之间的时间差，单位是毫秒，通常也将该值称作时间戳。 具体使用方法如下: arraycopy(Object src,int srcPos,Object dest,int destPos,int length) arraycopy()方法用于将一个数组中的元素快速拷贝到另一个数组，其中参数的具体作用如下， src:表示源数组 dest:表示目标数组 srcPos:表示源数组中拷贝元素的起始位置。 destPos:表示拷贝到目标数组的起始位置。 length:表示拷贝元素的个数。 在进行数组复制时，目标数组必须有足够的空间来存放拷贝的元素，否则会发生角标越界异常。 如上图所示:创建二个数组fromArray和toArray,分别代表源数组和目标数组。当调用arraycopy()方法进行元素拷贝时，由于指定了从源数组中索引为2的元素开始拷贝，并且拷贝4个元素存放在目标数组中索引为3的位置，因此在打印目标数组的元素时，程序首先打印的是数组toArray的前3个元素201、202、203，然后打印的是从fromArray中的4个元素。 System类还有二个常见的方法，分别是gc()和exit(int status)方法。其中，gc()方法用来启动Java的垃圾回收器，并且对内存中的垃圾对象进行回收。exit(int status)方法用来终止当前正在运行的Java虚拟机，其中参数status用于表示当前发生的异常状态，通常指定为0，表示正常退出，否则表示异常终止。 Running类Running类用于表示虚拟机运行时的状态，它用于封装JVM虚拟机进程。每次使用Java命令启动虚拟机都对应一个Running实例，因此该类采用单例模式进行设计，对象不可以直接实例化。若想在程序中获得一个Running实例，只能通过以下方式。 1Runtime run = Runtime.getRuntime(); 由于Running类封装了虚拟机进程，因此在程序中通常会通过该类的实例对象来获取当前虚拟机的相关信息。 如上图所示:Running.getRunning();方法创建了一个Runtime的实例对象，并分别调用该对象的availableProcessors()方法、freeMemory()方法，将当前虚拟机的处理器个数、空闲内存数和最大可用内存数的信息打印出来。由于每台计算机的配置和性能不同，该文件的打印结果也可能不同。另外，空闲内存数和可用最大内存数都是以字节为单位计算的。 Running类中提供了一个exec()方法，该方法用于执行一个dos命令，从而实现与在命令行窗口中输入dos命令同样的效果。如下实例: 调用了Running对象的exec()方法，并将系统命令”notepad.exe”作为参数传递给方法。运行程序会在桌面上打开一个记事本。运行上图程序以后，会在Windows系统产生一个新的进程notepad.exe。 Running类的exec()方法返回一个Process对象，该对象表示操作系统的一个进程，通过该对象可以对产生的新进程进行管理，如关闭此进程只需要调用destroy()方法即可。 Math类与Random类Math类Math类时数学操作类，提供了一系列用于数学运算的静态方法，包括求绝对值、三角函数等。Math类中有二个静态变量PI和E，分别代表数学常量π和e。如下图Math的常用方法: round()方法用于对某个小数进行四舍五入，此方法会将小数点后面的数字全部忽略，返回一个int类型的数，而ceil()方法和floor()方法返回的都是double类型的数，这个数在数值上等于一个整数。 Random类在JDK的Java.util包中有一个Random类，它可以在指定的范围内随机产生数字。在Random类中提供了二个构造方法，具体如下图所示: 上图列举了Random类的二个构造方法，其中第一个构造方法是无参的，通过它创建的Random实例对象每次使用的种子都是随机的，因此每个对象所产生的随机数不同。如果希望创建多个Random实例化对象产生相同序列的随机数，则可以在创建对象时调用第2个构造方法，传入相同的种子即可。通过以下实例采用第一种构造方法来产生随机数，如下所示： 运行二次产生的随机数序列是不一样的。这是因为当创建Random的实例对象时，没有指定种子，系统会以当前时间戳作为种子，产生随机数。 当创建Random类的实例化对象时，如果指定了相同的种子，则每个实例对象产生的随机数具有相同的序列。 相对于Math的random类提供了更多的方法来生成各种伪随机数，不仅可以生成整数类型的随机数，还可以生成浮点类型的随机数。如下图列举了Random类中的常用方法。 其中，Random类的nextDouble()方法返回的是0.0和1.0之间double类型的值，nextFloat()方法返回的是0.0~1.0之间float类型的值，nextInt(int n)返回的是0(包括)和指定值n(不包括)之间的值。 调用Random类不同的方法分别产生不同类型的随机数。 包装类在Java中，很多类的方法都需要接收引用类型的对象，此时就无法将一个基本数据类型的值传入。为了解决这样的问题，JDK中提供了一系列的包装类，通过这些包装类可以将基本数据类型的值包装为引用数据类型的对象。在Java中，每种基本类型都有对应的包装类。 上图列举了8种基本数据类型及其对应的包装类。其中，除了Integer和Character类，其他包装类的名称和基本数据类型的名称一致，只是类名的第一个字母需要大写。 包装类和基本数据类型在进行转换时，引入了装箱和拆箱的概念。其中，装箱是指将基本数据类型的值转为引用数据类型，反之，拆箱是指将引用数据类型的对象转为基本数据类型。如下图以int类型的包装类Integer为例，学习一下装箱过程。 包装类Integer的装箱过程，在创建Integer对象时，将int类型的变量a作为参数传入，从而转为Integer类型。由于Object类是所有类的父类，因此在输出语句中，可以通过调用toString()方法将Integer的值以字符串的形式打印出来。此处的toString()是可以省略的。 Integer类除了具有Object类的所有方法外，还有一些特有的方法，如下图所示。 列举了Integer的常用方法，其中的intValue()方法可以将Integer类型的值转为int类型，这个方法可以用来进行拆箱操作。接下来通过一个案例来演示intValue()方法的使用，如下图所示: 上图演示了拆箱的过程，Integer对象通过调用intValue()方法，将Integer对象转为int类型，从而可以与int类型的变量a进行加法运算，最终将运算结果正确打印。 parseInt()方法在程序中很常用，它是一个静态方法，用于将一个字符串形成的数据转为int类型。接下来用一个案例演示parseInt()方法的使用，该案例实现了在屏幕上打印“*”矩形，如下图所示。 程序运行时从键盘输入了二个参数，其中，第一个参数作为矩形的宽度，第二个参数作为矩形的高度。由于传入的参数都是字符串类型，不能直接使用，因此，通过调用包装类Integer的parseInt()方法将字符串转为整数，从而实现了矩形的打印。 在使用包装类时，需要注意一下几点。 包装类都重写了Object类中的toString()方法，以字符串的形式返回被包装的基本数据类型的值。 除了Character外，包装类都有valueOf(String s)方法，可以根据String类型的参数创建包装类对象，但参数字符串s不能为null，而且字符串必须是可以解析为相应基本类型的数据，否则虽然编译通过，但运行时会报错。 12Integer i = Integer.valueOf(&quot;123&quot;); //合法Integer i = Integer.valueOf(&quot;12a&quot;); //不合法 处理Character外，包装类都有parseXxx(String s)的静态方法，将字符串转换为对应的基本类型的数据。参数s不能为null，而且同样必须是可以解析为相应基本数据类型的数据，否则虽然编译通过，但运行报错。 12int i = Integer.parseInt(&quot;123&quot;); //合法Integer in = Integer.parseInt(&quot;hello&quot;);//不合法 JDK5.0新特性—自动拆箱和装箱 在JDK5.0版本之前，数学运算表达式中操作数必须是基本类型的，并且运行结果也是基本类型，包装类和基本类型是不允许进行混合数学运算的，如果想运算，必须要通过拆箱将包装类对象转为基本数据类型的值才行。 1234int a = 1; //合法int b = a + 1; //合法Integer c = a + b; //不合法，编译出错b = a + (new Integer(1));//不合法，编译报错 在JDK5.0的版本中提供了自动拆箱和装箱技术，也就是可以自动进行基本数据类型和包装类对象之间的转换，具体如下: 12int num = 20;Integer number = num; //自动装箱 上面的代码就是自动装箱，相当于程序自动执行了语句“Integer number = new Integer(num);”。 12Integer number = new Integer(18);int number2 =number;//自动拆箱 上面的代码就是自动拆箱，相当于程序自动执行了语句“int number2=number.intValue();”。 正因为自动拆箱装箱的特性，在JDK5.0版本以后，基本类型和包装类型可以进行混合数学运算，也可以直接将二个Integer类型进行数学运算，具体示例如下。 123public static Integer add(Integer a,Integer b)&#123; return a+b;&#125; JDK7.0新特性–switch语句支持字符串类型在JDK7.0中，switch语句的表达式增加了对字符串类型的支持。由于字符串的操作在编程中使用频繁，这个新特性的出现为Java编程带来了便利。如下演示:switch语句中使用字符串进行匹配。 switch语句条件表达式的值为“Friday”,与case条件中的字符串“Friday”相匹配，因此打印出“星期五”。 本章小结记录一个子串在整串中出现的次数1234567891011121314151617181920212223242526package Project;public class StringTest &#123; public static void main(String[] args) &#123; String str = &quot;qwertyuioqwertyuiwertyu&quot;; //整串 String key = &quot;ert&quot;; //子串 int count = getKeyStringCount(str,key); System.out.println(&quot;count=&quot;+count); &#125; //获取子串在整串中出现的次数 private static int getKeyStringCount(String str, String key) &#123; //定义计数器，记录出现的次数 int count = 0; //如果整串中不包含子串，则直接返回count if(!str.contains(key))&#123; return count; &#125; //定义变量记录key出现的位置 int index=0; while((index=str.indexOf(key))!=-1)&#123; str = str.substring(index+key.length()); count++; &#125; return count; &#125;&#125; 字符串排序程序设计1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Project;import java.util.Arrays;public class WrapperTest &#123; private static final String SPACE_SEPARATOR = &quot; &quot;; public static void main(String[] args) &#123; String numStr = &quot;20 12 35 -5 -56 99&quot;; System.out.println(numStr); numStr = sortStringNumber(numStr); System.out.println(numStr.toString()); &#125; public static String sortStringNumber(String numStr) &#123; //将字符串变成字符串数组 String[] str_arr = stringToArray(numStr); //将字符串数组变成int数组 int[] num_arr = toIntArray(str_arr); //对int数组排序 mySortArray(num_arr); //将排序以后的int数组变成字符串 String temp = arrayToString(num_arr); return temp; &#125; public static String arrayToString(int[] num_arr) &#123; StringBuffer sb = new StringBuffer(); for (int x = 0; x &lt; num_arr.length; x++) &#123; if(x!=num_arr.length-1)&#123; sb.append(num_arr[x]+SPACE_SEPARATOR); &#125;else &#123; sb.append(num_arr[x]); &#125; &#125; return sb.toString(); &#125; public static void mySortArray(int[] num_arr) &#123; Arrays.sort(num_arr); &#125; public static int[] toIntArray(String[] str_arr) &#123; int[] arr = new int[str_arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = Integer.parseInt(str_arr[i]); &#125; return arr; &#125; public static String[] stringToArray(String numStr) &#123; String[] str_arr = numStr.split(SPACE_SEPARATOR); return str_arr; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象-下]]></title>
    <url>%2F2019%2F02%2F25%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[类的继承继承的概念在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。 在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。在程序中，如果想要声明一个类继承另一个类，需要使用extends关键字。 注意：public class XX 与你创建该类时所写的名字不符，不管你什么类,只要是Class,就只能有一个public class(公共类) 子类在继承父类的时候，会自动拥有父类所有的成员。 在类的继承中，需要注意一些问题，具体如下： 在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类。 123class A&#123;&#125;class B&#123;&#125;class C extends A,B&#123;&#125;//C类不可以直接同时继承A类和B类 多个类可以继承一个父类。 123class A&#123;&#125;class B extends A&#123;&#125;class C extends A&#123;&#125;//类B和类C都可以继承类A 在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类。 1234class A&#123;&#125;class B extends A&#123;&#125;//类B继承类A,类B是类A的子类class C extends B&#123;&#125;//类C继承类B,类C继承类B的子类，同时也是类A的子类 在Java中，子类和父类是一种相对概念，也就是说一个类是某个类的父类的同时，也可以是另一个类的父类。 重写父类方法在继承关系中，子类会自动继承父类中定义的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。需要注意的是，在子类中重写的方法需要和父类被重写的方法具有相同的方法名、参数列表以及返回值类型。 注意:子类重写父类方法时，不能使用比父类中被重写的方法更严格的访问权限，如：父类中的方法是public的，子类的方法就不能是private的。 super关键字当子类重写父类的方法以后，子类对象将无法访问父类被重写的方法。为了解决这个问题，Java中专门提供了一个super关键字用于访问父类成员。例如访问成员父类的成员变量、成员方法和构造方法。 使用super关键字访问父类的成员变量和成员方法，具体格式如下。 12super.成员变量super.成员方法([参数1,参数2,···]) 使用super关键字访问父类的构造方法。 1super([参数1,参数2····]) 实例化Dog对象时，一定会调用Dog类的构造方法。从运行结构可以看出，Dog类的构造方法被调用时，父类的构造方法也被调用了。需要注意，通过super调用父类构造方法的代码必须位于子类构造方法的第一行，并且只能出现一次。 子类在实例化时默认调用了父类无参的构造方法。在定义一个类时，如果没有特殊需求，尽量在类中定义一个无参的构造方法，避免被继承时出现错误。 final关键字final关键字可用于修饰类、变量和方法，它有“无法改变”或者“最终”的含义，因此被final修饰的类、变量和方法将具有以下特性。 final修饰的类不能被继承。 final修饰的方法不能被子类重写。 final修饰的变量(成员变量和局部变量)是常量，只能赋值一次。 final关键字修饰类Java中的类被final关键字修饰以后，该类将不可以被继承，也就是不能够派生子类。 final关键字修饰方法当一个类的方法被final关键字修饰以后，这个子类将不能重写该方法。正是由于final的这种特性，当父类中定义某个方法时，如果不希望被子类重写，就可以使用final关键字修饰该方法。 final关键字修饰变量Java中被修饰的变量，它只能被赋值一次，也就是说final修饰的变量一旦被赋值，其值不能改变。如果再次对变量进行赋值，则程序会在编译时报错。 使用final关键字修饰成员变量时，虚拟机不会对其进行初始化。因此使用final修饰成员变量时，需要在定义变量的同时赋予一个初值。 抽象类和接口抽象类当定义一个类时，常常需要定义一些方法来描述该类的行为特征，但有时这些方法的实现方式是无法确定的。例如:,前面在定义Animal类时，shout()方法用于表示动物的叫声，但是针对不同的动物，叫声也是不同的，因此在shout()方法中无法确定描述动物的叫声。 针对上面描述的情况，Java允许在定义方法时不写方法体。不包含方法体的方法为抽象方法，抽象方法必须使用abstract关键字来修饰。 1abstract void shout();//定义抽象方法shout() 当一个类中包含了抽象方法，该类必须使用abstract关键字来修饰，使用abstract关键字修饰的类为抽象类。 12345//定义抽象类Animalabstract class Animal&#123; //定义抽象方法shout() abstract int shout();&#125; 在定义抽象类需要注意，包含抽象方法的类必须声明为抽象类，但抽象类可以不包含任何抽象方法，只需要使用abstract关键字来修饰即可。另外，抽象类是不可以被实例化的，因为抽象类中可能包含抽象方法，抽象方法是没有方法体的，不可以被调用。如果想要调用抽象类中定义的方法，则需要创建一个子类，在子类中将抽象类中的抽象方法进行实现。 子类实现了父类的抽象方法后,可以进行实例化，并通过实例化对象调用方法。 接口如果一个抽象类中的所有方法都是抽象的，则可以将这个类用另一种方式来定义，即接口。接口是由常量和抽象方法组成的特殊类，是对抽象类的进一步抽象。 在定义接口时，需要使用interface关键字来声明，其语法格式如下： 1234[public] interface 接口名 []&#123; [public] [static] [final] 数据类型 常量名 = 常量值; [public] [abstract] 返回值 抽象方法名(参数列表);&#125; 在上面的语法中，一个接口可以有多个父接口，它们之间用逗号隔开。Java使用接口的目的是为了克服单继承的限制，因为一个类只能有一个父类，而一个类可以实现多个接口。接口中的变量默认使用”public static final”来修饰，即全局常量；接口中定义的方法默认使用“public abstract” 来修饰,即抽象方法。如果接口声明为public，则接口中变量和方法全部为public。 由于接口中方法都是抽象方法，因此不能通过实例化对象的方式来调用接口中的方法。此时需要定义一个类，并使用implements关键字实现接口中的所有方法。一个类可以在继承另一个类的同时实现多个接口，这些接口在implements子句中要使用英文逗号(,)隔开。接口的实现类声明格式如下。 1[&lt;修饰符&gt;] class &lt;类名&gt; [extends&lt;超类名&gt;] [implements &lt;接口1&gt;,&lt;接口2&gt;,···] 从结果中可以看出，类Dog在实现了Animal接口后是可以被实例化的，并且实例化后就可以调用Dog类中的方法。需要注意的是，一个类实现一个一个接口，必须给出接口中所有方法的实现，如果不能实现某方法，也必须写出一个空方法。 在程序中，还可以定义一个接口使用extends关键字去继承另一个接口。 接口中的方法都是抽象的，不能实例化对象。 接口中的属性只能是常量。 当一个类实现接口时，如果这个类是抽象类，则实现接口中的部分方法即可，否则需要实现接口中的所有方法。 一个类通过implements关键字实现接口时，可以实现多个接口，被实现的多个接口之间用逗号隔开，具体如下: 123456789interface Run&#123; 程序代码····&#125;interface Fly&#123; 程序代码····&#125;class Bird implements Run,Fly&#123; 程序代码····&#125; 一个接口可以通过extends关键字继承多个接口，接口之间用逗号隔开，具体如下。 123456789interface Running&#123; 程序代码····&#125;interface Flying&#123; 程序代码···&#125;interface Eating extends Running,Flying&#123; 程序代码····&#125; 一个类在继承另一个类的同时还可以实现接口，此时，extends关键字必须位于implements关键字之前，具体实例如下: 123class Dog extends Canidae implements Animal&#123; //先继承，在实现 程序代码····&#125; 多态多态概述在设计一个方法时，通常希望该方法具备一定的通用性。在同一个方法中，这种由于参数类型不同而导致执行效果各异的现象就是多态。继承是多态得以实现的基础。 在Java中，为了实现多态，允许使用一个父类类型的变量来引用一个子类类型的对象，根据被引用子类对象特征的不同，得到不同的运行结果。代码如下: 多态不仅解决了方法同名的问题，而且还使程序变得更加灵活，从而有效地提高了程序的可扩展性和可维护性。 对象的类型转换在多态的学习中，涉及到将子类对象当作父类类型使用的情况，此种情况在Java的语言环境称为“向上转型”。 12Animal an1 = new Cat();//将Cat对象当作Animal类型来使用Animal an2 = new Dog();//将Dog对象当作Animal类型来使用 将子类对象当作父类使用时不需要任何显示地声明，需要注意的是，此时不能通过父类变量去调用子类中特有方法。 通过运行结果可以看出，将传入的对象由Animal类型转为Cat类型后，程序可以成功调用shout()和sleep()方法，这种将父类型当作子类型使用的情况，在Java的语言环境中被称为“向下转型”。 需要注意的是，在进行类型转换时也可能出现错误。 针对这种情况，Java提供了一个关键字instanceof,它可以判断一个对象是否为某个类(或接口)实例或者子类实例，语法格式如下。 1对象(或者对象引用变量) instanceof 类(或接口) Object类在JDK中提供了一个Object类，它是类层次结构的根类，每个类都直接或间接继承自该类，所有对象（包括数组）都实现了这个方法。Object类的常用方法如下图: 在代码中调用了Animal对象的toString()方法，虽然Animal类并没有定义这个方法，但程序并没有报错。这是因为Animal类默认继承自Object类,在Object类中定义了toString()方法，在该方法中输出了对象的基本信息，Object类中的toString()方法中的代码具体如下。 1getClass().getName()+&quot;@&quot;+Integer.toHexString(hashCode()); getClass().getName()代表返回对象所属类的类名，即Animal。 hashCode()代表返回该对象的哈希值。 Integer.toHexString(hashCode())代表将对象的哈希值用十六进制表示。 其中hashCode()是Object类中定义的一个方法，这个方法将对象的内存地址进行哈希运算，返回一个int联系的哈希值。 在实际开发中，通常希望对象的toString()方法返回的不仅仅是基本信息，而是一些特有信息。这是重写Object的toString()方法便可以实现。 匿名内部类在编写Java程序时，在类里面定义的类称之为内部类(Inner Class)内部类是外部类的一个成员。Java内部类可以分为成员内部类，方法内部类和匿名内部类等。 在前面多态的讲解中，如果方法参数被定义为一个参数类型，那么就需要定义一个类来实现接口，并根据该类进行对象实例化。除此之外，还可以使用匿名内部类来实现接口。所谓匿名内部类就是没有名字的内部类，表面上看起来它似乎有名字，实际上那并不是它的名字。当程序中使用匿名内部类时，在定义匿名内部类的地方往往直接创建该类的一个对象。 上图中，内部类Cat实现了Animal接口，在调用animalShout()方法时，将Cat类的实例对象作为参数传入到方法中，从而输出相应的结果。 匿名内部类的格式，具体如下： 123new 父类(参数列表) 或 父接口()&#123; //匿名内部类实现部分&#125; 上二张图结果一样，但在其代码中使用匿名内部类实现的Animal接口。接下来分二个步骤来编写匿名内部类。 在调用animalShout()方法时，在方法的参数位置写上new Animal(){},这相当于创建了一个实例对象，并将参数传给animalShout()方法。在new Animal()后面有一对大括号表示创建的对象为Animal的子类实例，该子类是匿名的。 1animalShout(new Animal()&#123;&#125;); 在大括号中编写匿名子类的实现代码 123456animalShout(new Animal() &#123; public void shout()&#123; System.out.println(&quot;喵喵···&quot;); &#125; &#125;); 匿名内部类是实现接口的一种简便写法，在程序中不一定非要使用匿名内部类。 异常什么是异常在程序运行的过程中，也会发生各种非正常状况，例如程序运行时磁盘空间不足、网络连接中断、被装载的类不存在等。针对这种情况，在Java语言中，引入了异常，以异常类的形式对这些非正常情况进行封装，通过异常处理机制对程序运行时发生的各种问题进行处理。 从结果可以看出，程序发生了算数异常(AnithmeticException)，这个异常是由于调用divide()方法时传入了参数0，而在divide()方法中，运算时出现了被0除的情况。在这个异常发生后，程序会立即结束，无法继续向下执行。 AnithmeticException异常只是Java异常类中的一种，在Java中还提供了大量的异常类，这些类都继承自java.lang.Throwable类。 如上可以看出，Throwable有二个直接子类Error和Exception。其中，Error代表程序中产生的错误，Exception代表程序中产生的异常。 Error类成为错误类，它表示Java运行时产生的系统内部错误或资源耗尽的错误，是比较严重的，紧靠修改程序本身是不能恢复执行的。使用Java命令运行一个不存在的类就会出现Error错误。 Exception类称为异常类，它表示程序本身可以处理的错误。在开发Java程序中进行的异常处理都是针对Exception类及其子类。在Exception类的众多子类中有一个特殊的RuntimeException类，该类及其子类用于表示运行时异常。除了此类，Exception类下所有其他的子类都用于表示编译时异常。 如下Throwable类中的常用方法: 这些方法都用于获取异常信息。由于Error和Exception继承自Throwable类，所以他们都拥有这些方法。 try…catch和finally由于发生异常导致程序立即终止，所以无法继续向下执行了。为了解决这样的问题，Java中提供了一种对异常进行处理的方式–异常捕获。异常捕获通常使用try…catch语句，具体格式如下。 12345try&#123; //程序代码块 &#125;catch(ExceptionType(Exception类及其子类)e)&#123; //对ExceptionType的处理 &#125; 其中，在try代码块中编写可能发生的异常的Java语句，catch代码块中编写针对异常进行处理的代码。当try代码块中的程序发生异常，系统会将这个异常的信息封装成一个异常的对象，并将这个对象传递给catch代码块。catch代码块需要一个参数指明它所能够接收的异常类型，这个参数的类型必须是Exception类或其他子类。 在try代码块中，发生异常语句后面的代码是不会被执行的 有时候会希望有些语句无论程序是否发生异常都要执行，这时就可以在try···catch语句后面加一个finally代码块。 在程序设计时，经常会在try···catch后使用finally代码块来完成必须要做的事情，例如释放资源。 需要注意的是，finally中的代码块在一般情况下是不会执行的，那就是在try···catch中执行了System.exit(0)语句。System.exit(0)表示退出当前的Java虚拟机，Java虚拟机停止了，任何代码都不能再执行了。 throws关键字针对这种情况，Java中允许在方法的后面使用throw关键字对外声明该方法有可能发生异常，这样调用者在调用方法时，就明确地知道该方法有异常，并且必须在程序中的异常进行处理，否则编译不能通过。 throws关键字声明抛出异常的语法格式如下。 1234修饰符 返回值类型 方法名([参数1,参数2···])throws ExceptionType1[ ,Exception Type2····]&#123;&#125; 从上述语法格式中可以看出，throw关键字需要写在方法声明的后面，throws后面需要声明方法中发生异常的类型，通常将这种做法称为方法声明抛出一个异常。 运行时异常与编译时异常在实际开发过程中，经常会在程序编译时产生一些异常，而这些异常必要进行处理，这种异常被称为编译时异常，也称为checked异常。另外还有一种异常是在程序程序运行时产生的，这种异常即使不编写异常处理代码，依然可以通过编译，因此被称为运行时异常，也称为unchecked异常。 编译时异常 在Java中，Exception类除了RuntimeException类及其子类外都是编译时异常。编译时异常的特点是Java编译器会对其进行检查，如果出现异常就必须对异常进行处理，否则程序无法通过编译。 处理编译时期的异常有二种方式，具体如下。 使用try···catch语句对异常进行捕获。 使用throws关键字声明抛出异常，调用者对其处理。 运行时异常 RuntimeException类及其子类都是运行时异常。运行时异常的特点是Java编译器不会对其进行检查。也就是说，当程序中出现这类异常时，即使没有使用try···catch语句捕获或使用throws关键字声明抛出，程序也能编译通过。运行时异常一般是由程序中的逻辑错误引起的，在程序运行时无法恢复。 自定义控制JDK中定义了大量的异常类，虽然这些异常类可以描述编程时出现的大部分异常情况，但是在程序开发中有时可能需要描述程序中特有的异常情况。在Java中允许用户自定义异常，但自定义异常的异常类必须继承自Exception或其子类。 在实际开发中，如果没有特殊的要求，自定义的异常类只需继承Exception类，在构造方法中使用super()语句调用Exception的构造方法即可。 throw关键字用于在方法中声明抛出异常的实例化对象，其语法格式如下。 throw Exception 异常对象 在一个方法内使用throw关键字抛出异常对象时，需要try···catch语句对抛出的异常进行处理。 访问控制在Java中，针对类、成员方法和属性提供了4种访问级别，分别是private、default、protected和public。 private(类访问级别):如果类的成员被private访问控制符来修饰，则这个成员只能被该类的其他成员访问，其他类无法直接访问。类的良好封装就是通过private关键字来实现的。 default(包访问级别):如果一个类或者类的成员不使用任何访问控制符修饰，则称它为默认访问控制级别，这个类或者类的成员只能被本包中的其他类访问。 protected(子类访问级别):如果一个类的成员被protected访问控制符修饰，那么这个成员既能被同一个包下的其他类访问，也能被不同包下该类的子类访问。 public(公共访问级别):这是一个最宽松的访问控制级别，如果一个类或者类的成员被public访问修饰符修饰，那么这个类或者类成员能被所有的类访问，不管访问类与被访问类是否在同一个包中。 本章小结USB接口程序设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package kang;//定义一个名称为USB的接口public interface USB &#123; void turnOn();//启动 void turnOff();//关闭&#125;package kang;//鼠标public class Mouse implements USB &#123; public void turnOn()&#123; System.out.println(&quot;鼠标打开了&quot;); &#125; public void turnOff()&#123; System.out.println(&quot;鼠标关闭了&quot;); &#125;&#125;package kang;//键盘public class KeyBoard implements USB &#123; public void turnOn()&#123; System.out.println(&quot;键盘打开了&quot;); &#125; public void turnOff()&#123; System.out.println(&quot;键盘关闭了&quot;); &#125;&#125;package kang;//麦克风public class Mic implements USB &#123; public void turnOn()&#123; System.out.println(&quot;麦克风打开了&quot;); &#125; public void turnOff()&#123; System.out.println(&quot;麦克风关闭了&quot;); &#125;&#125;package kang;//计算机public class Computer &#123; //计算机上的USB插槽 private USB[] usbArr = new USB[4]; //向计算机连接一个USB设备 public void add(USB usb)&#123; //循环遍历所有插槽 for(int i=0;i&lt; usbArr.length;i++)&#123; //如果发现一个是空的 if(usbArr[i]==null)&#123; //将usb设备连接在这个插槽上 usbArr[i]=usb; //连接上以后循环结束 break; &#125; &#125; &#125; //计算机开机功能 public void powerOn()&#123; //循环遍历所有插槽 for(int i=0;i&lt;usbArr.length;i++)&#123; //如果发现有设备 if(usbArr[i]!=null)&#123; //将USB设备启动 usbArr[i].turnOn(); &#125; &#125; System.out.println(&quot;计算机开机成功&quot;); &#125; //计算机关机功能 public void powerOff()&#123; for(int i=0;i&lt;usbArr.length;i++)&#123; if(usbArr[i]!=null)&#123; usbArr[i].turnOff(); &#125; &#125; System.out.println(&quot;计算机关机成功&quot;); &#125;&#125;package kang;//测试类 class Task01Test &#123; public static void main(String[] args)&#123; //实例化计算机对象 Computer c = new Computer(); //向计算机中添加鼠标、麦克风和键盘设备 c.add(new Mouse()); c.add(new Mic()); c.add(new KeyBoard()); c.powerOn();//启动计算机 System.out.println(); c.powerOff();//关闭计算机 &#125;&#125; 模拟物流快递系统程序设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194package www;/* * 交通工具类 * */public abstract class Transportation &#123; private String number; //编号 private String model; //型号 private String admin; //运货负责人 public Transportation()&#123; super(); //可省略 &#125; public Transportation(String number,String model,String admin)&#123; this.number=number; this.model = model; this.admin=admin; &#125; //运输方式 public abstract void transport(); //编号 public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; //型号 public String getModel() &#123; return model; &#125; public void setModel(String model) &#123; this.model = model; &#125; //负责人 public String getAdmin() &#123; return admin; &#125; public void setAdmin(String admin) &#123; this.admin = admin; &#125;&#125;package www;/* * 定义保养借口，具有保养功能 */public interface Careable &#123; //保养方法 public abstract void upKeep();&#125;package www;/* * 专用运输车类 */public class ZTransportation extends Transportation implements Careable &#123; //无参构造 public ZTransportation()&#123; super(); &#125; //有参构造：车辆编号、型号、负责人 public ZTransportation(String number,String model,String admin)&#123; super(number,model,admin); &#125; //运输方法 public void transport()&#123; System.out.println(&quot;运输进行中····&quot;); &#125; //重写车辆保养方法 public void upKeep()&#123; System.out.println(&quot;货物运输车辆保养完毕！&quot;); &#125; &#125;package www;/* * 快递任务 */public class SendTask &#123; private String number;//快递单号 private double goodsWeight;//货物重量 public SendTask()&#123; super();//可省略 &#125; public SendTask(String number,double goodsWeight)&#123; this.number= number; this.goodsWeight=goodsWeight; &#125; //送前准备 public void sendBefore()&#123; System.out.println(&quot;订单开始处理，仓库验货中···&quot;); System.out.println(&quot;货物重量:&quot;+this.getGoodsWeight()+&quot;kg&quot;); System.out.println(&quot;货物检验完毕！&quot;); System.out.println(&quot;货物填装完毕！&quot;); System.out.println(&quot;运货人已通知&quot;); System.out.println(&quot;快递单号:&quot;+this.getNumber()); &#125; //发送货物 public void send(Transportation t,GPS tool)&#123; System.out.println(&quot;运货人&quot;+t.getAdmin()+&quot;正在驾驶编号为&quot;+t.getNumber()+&quot;的&quot;+t.getModel()+&quot;发送货物!&quot;); t.transport(); String showCoordincate = tool.showCoordinate(); System.out.println(&quot;货物当前的坐标为:&quot;+showCoordincate); &#125; public void sendAfter(Transportation t)&#123; System.out.println(&quot;货物运输任务完成!&quot;); System.out.println(&quot;运货人&quot;+t.getAdmin()+&quot;正在驾驶编号为&quot;+t.getNumber()+&quot;的&quot;+t.getModel()+&quot;已归还!&quot;); &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public double getGoodsWeight() &#123; return goodsWeight; &#125; public void setGoodsWeight(double goodsWeight) &#123; this.goodsWeight = goodsWeight; &#125; &#125;package www;/* * 定义GPS借口，具备GPS定位功能 */public interface GPS &#123; //显示坐标的方法 public String showCoordinate();&#125;package www;/* * 定义一个手机类，实现GPS接口，拥有定位功能 */class Phone implements GPS &#123; public Phone()&#123;//空参构造 super(); &#125; //定位方法 public String showCoordinate()&#123; String location = &quot;193.485&quot;; return location; &#125;&#125;package www;public class Task02Test &#123; /** * 定义测试类 */ public static void main(String[] args) &#123; // 快递任务类对象 SendTask task = new SendTask(&quot;HYX600235&quot;,76.34); //调用送前准备方法 task.sendBefore(); //创建交通工具对象 System.out.println(&quot;=========================&quot;); //创建GPS工具对象 ZTransportation t = new ZTransportation(&quot;Z025&quot;,&quot;大本&quot;,&quot;小韩&quot;); //将交通工具与GPS工具传入送货方法 Phone p = new Phone(); //调用送后操作方法 task.send(t,p); System.out.println(&quot;=========================&quot;); task.sendAfter(t); t.upKeep(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序入门-布局]]></title>
    <url>%2F2019%2F02%2F15%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8-%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[选择器类选择器 class .点号开始 文件名不要用中文 多个地方被使用 一个地方可以使用多个 后面的优先级高 element 全局 使用不多 组合选择器,逗号分隔Id选择器#井号开始后代选择器，空格分隔颜色和字体颜色三原色:由于人类肉眼有三种不同颜色的感光体，因此所见的色彩空间通常可以由三种基本色表达。 红，绿，蓝。 1234/* 红 绿 蓝 */ color: rgb(255, 255, 255)/*2^8-1*/ color: #ffffff;/*十六进制*/ color: red;/*别称*/ 那些地方使用颜色，字体，背景，边框，阴影 1234color: blue; /*字体颜色*/ background-color: #000000;/*背景颜色*/ box-shadow: 0 0 5px #5F687E;/*阴影颜色*/ border: 4px solid #ffffff;/*边框颜色*/ 字体123font-size: 17px; /*字体大小*/font-family: &quot;宋体&quot;; /*字体样式 尽量不要动*/font-weight: bold; /*字体加粗*/ 盒模型 外边距、内边距、边框和内容部分 做小程序时候尽量不用px，使用% box-sizing content-box border-box(不懂不要动) 1234margin: 10px;/*外边距 px像素点*/padding: 10px;/*内边距*/border: 10px dashed #000000;/*边框*//* 宽度 样式 颜色 */ 定位position 元素的定位方式 static 静态 relative 相对 absolute 绝对 fixed 固定]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象-上]]></title>
    <url>%2F2019%2F02%2F11%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[面向对象的概念面向对象是一种符合人类思维的编程思想。现实生活中存在各种形态的不同的事物，这些事物之间存在着各种各样的联系。在程序中使用对象来映射现实中的事物，使用对象的关系来描述事物之间的联系，这种思想就是面向对象。 面向过程：面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一一实现，使用的时候依次调用就可以了。 面向对象则是把构成问题的事务按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。当然，一个程序会包含多个对象，通过多个对象的相互配合来实现应用程序的功能，这样当应用程序功能发生变动时，只需要修改个别的对象就可以了，从而使代码更容易得到维护。面向对象的特点可以概括为封装性、继承性、多态性。 封装性 封装是面向对象的核心思想，将对象的属性和行为封装起来，不需要让外界知道具体实现细节，这就是封装思想。 继承性 继承性主要描述的是类与类之间的关系，通过继承，可以在无需重新编写原有类的情况下，对原有类的功能进行拓展。继承不仅增强了代码的复用性，提高了开发效率，还为程序的维护补充提供了便利。 多态性 多态性指的是在程序中允许出现重名现象，它指在一个类中定义的属性和方法被其他类继承后，它们可以具有不同的数据类型或表现出不同的行为，这使得同一个属性和方法在不同的类中具有不同的语义。 类与对象面向对象的编程思想，力图让程序中对事物的描述与该事物在现实中的形态保持一致。为了做到这一点，面向对象的思想中提出了二个概念，即类和对象。类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体。 类用于描述多个对象的共同特征，它是对象的模板。对象用于描述现实中的个体，它是类的实例。对象是根据类创建的，并且一个类可以对应多个对象。 类的定义类是对象的抽象，它用于描述一组对象的共同特征和行为。类中可以定义成员变量和成员方法，其中成员变量用于描述对象的特征，也被称作属性；成员方法用于描述对象的行为，可以简称为方法。实例如下： 1234567class Person&#123; int age; //定义int类型的变量age //定义speak（）方法 void speak()&#123; System.out.println(&quot;大家好，我今年&quot;+age+&quot;岁&quot;); &#125;&#125; Person 是类名，age是成员变量，speak()是成员方法。在成员方法speak()中可以直接访问成员变量age。 对象的创建与使用应用程序想要完成具体的功能，仅有类是远远不够的，还需要根据类创建实例对象。在Java程序中可以使用new关键字来创建对象，如下： 12类名 对象名称 = new 类名();Person p = new Person();//例子 “new Person()”用于创建Person类的一个实例对象，”Person p”则是声明了一个Person类型的变量p。中间的等号用于将Person对象在内存中的地址赋值给变量p，这样变量p便持有了对象的引用。为了方便描述，通常会将变量p引用的对象简称为p对象。 在创建Person对象后，可以通过对象的引用来访问对象所有的成员。 对象引用.对象成员 具体如下实例 p1、p2分别引用了Person类的二个实例对象。p1对象和p2对象是二个完全独立的个体，它们分别拥有各自的age属性，对p1对象的age属性进行赋值并不会影响到p2对象age的属性。 在实例化对象时，Java虚拟机会自动为成员变量进行初始化，针对不同类型的成员变量，Java虚拟机会赋予不同的初始值。如下所示： 当对象被实例化以后，在程序中可以通过对象的引用变量来访问该对象的成员。需要注意的是，当没有任何变量引用这个对象时，它将成为垃圾对象，不能在被使用。 类的设计例子：先定义一个学生类(Student),在这个类中定义二个属性name、age，分别表示学生的姓名和年龄，定义一个方法introduce()表示学生的自我介绍。 123456789public class Student &#123; String name; //定义一个姓名属性 int age; //定义一个年龄属性 public void introduce()&#123; //方法中打印属性name和age的值 System.out.println(&quot;大家好，我叫&quot;+name+&quot;,我今年&quot;+age+&quot;岁！&quot;); &#125;&#125; 类的封装所谓类的封装是指在定义一个类时，将类中的属性私有化，即使用private关键字来修饰。私有属性只能在它所在类中被访问，如果外界想要访问私有属性，需要提供一些使用public修饰的公有方法，其中包括用于获取属性值的getXxx方法和设置属性值的setXxx方法。具体如下： 当获取年龄不合法时，age属性没有被赋值，认为初值0。 构造方法实例化一个类的对象以后，如果要为这个对象中的属性赋值，则必须要通过直接访问对象的属性或调用setXxx方式才可以。如果需要在实例化对象的同时就为这个对象属性进行赋值，可以通过构造方法来实现。构造方法是类的一个特殊成员，它会在类实例化对象时被自动调用。 构造方法的定义在一个类中定义的方法如果同时满足以下3个条件，该方法称为构造方法。 方法名与类名相同。 在方法名的前面没有返回值类型的声明。 在方法中不能使用return语句返回一个值，但是可以单独写return语句来作为方法的结束。 如下： 构造方法的重载与普通方法一样，构造方法也可以重载，在一个类中可以定义多个构造方法，只要每个构造方法的参数类型或参数个数不同即可。在创建对象时，可以通过不同的构造方法来为不同的属性进行赋值。如下例子： 注意： 在Java中的每一个类都至少有一个构造方法，如果在一个类中没有定义构造方法，系统会自动为这个类创建一个默认的构造方法，这个默认的构造方法没有参数，在其方法体中没有任何代码，即什么都不做。 private关键字修饰的构造方法Person()只能在Person类中被访问。也就是说，Person()构造方法是私有的，不能被外界调用，也就无法在类的外部创建该类的实例对象。因此，为了方便实例化对象，构造方法通常会使用public来修饰。 this关键字为了解决导致成员变量和局部变量的名称冲突，Java中提供了一个关键字this来指代当前对象，用于在方法中访问对象的其它成员。 this关键字在程序中的3种常见用法 通过this关键字可以明确地去访问一个类的成员变量，解决与局部变脸名称冲突问题。 通过this关键字调用成员方法。 构造方法是在实例化对象时被Java虚拟机自动调用的，在程序中不能像调用其他方法一样去调用构造方法，但可以在一个构造方法中使用“this([参数 1,参数 2 ….])”的形式来调用其他的构造方法。 在使用this调用类的构造方法时，应注意以下几点。 只能在构造方法中使用this调用其他的构造方法，不能在成员方法中使用。 在构造方法中，使用this调用构造方法的语句必须位于第一行，且只能出现一次。 不能在一个类的二个构造方法中使用this互相调用。 垃圾回收在Java中，当一个对象成为垃圾后仍会占有内存空间，时间一长，就会导致内存空间的不足。针对这种情况，Java中引用了垃圾回收机制。有了这种机制，程序员不需要过多的关心垃圾对象回收的问题，Java虚拟机会自动回收垃圾对象所占用的内存空间。 一个对象在成为垃圾后会暂时地保存到内存中，当这样的垃圾堆积到一定程度时，Java虚拟机就会启动垃圾回收器将这些垃圾对象从内存中释放，从而使程序获得更多的内存空间。除了等待Java虚拟机进行自动垃圾回收以外，还可以通过调用System.gc()方法来通知Java虚拟机立即进行垃圾回收。当一个对象在内存中被释放时，它的finalize()方法会自动被调用，因此可以在类中通过定义finalize()方法来观察对象何时被释放。 static关键字在Java中定义了一个static关键字，它用于修饰类的成员，如成员变量、成员方法以及代码块等，被static修饰的成员具备一些特殊性。 静态变量在定义一个类时，只是在描述某类事物的特征和行为，并没有产生具体的数据。只有通过new关键字创建类的实例对象后，系统才会为每个对象分配空间，存储各自的数据。有时候，开发人员会希望某些特定的数据只有一份，而且能够被一个类的所有实例对象所共享。 在一个Java类中，可以使用static关键字来修饰成员变量，该变量被称作静态变量。静态变量被所有实例共享，可以使用”类名.变量名”的形式来访问。 static关键字只能用于修饰成员变量，不能用于修饰局部变量，否则编译会报错。 静态方法在实际开发过程中，开发人员希望在不创建对象的情况下就可以调用某个方法，换句话说也就是使该方法不必和对象绑在一起。要实现这样的效果，只需要在类中定义的方法前加上static关键字即可，通常称这种方法为静态方法。同静态变量一样，静态方法可以使用”类名.方法名”的方式来访问，也可以通过类的实例对象来访问。 在一个静态方法中只能访问用static修饰的成员，原因在于没有被static修饰的成员需要先创建对象才能访问，而静态方法可以在被调用时可以不创建任何对象。 静态代码块在Java类中，使用一对大括号包围起来的若干行代码被称为一个代码块，使用static关键字修饰代码块称为静态代码块。当类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块只执行一次。在程序中，通常会使用静态代码块来对类的成员变量进行初始化。 Java虚拟机首先会加载类Example01,在加载类的同时就会执行该类的静态代码块，紧接着会调用main()方法。在该方法中创建了二个Person对象，但在二次实例化对象的过程中，静态代码块中的内容只输出一次，这就说明静态代码块在类第一次使用时才会被加载，而且只会加载一次。 成员内部类在Java中，允许在一个类的内部定义一个类，这样的类称作内部类，这个内部类所在的类称作外部类。根据内部类的位置、修饰符和定义的方式可分为成员内部类、静态内部类、方法内部类。 在成员内部类中，可以访问外部类的成员。 如果想通过外部类去访问内部类,则需要通过外部类对象去创建内部类对象，创建内部类对象的具体语法格式如下： 外部类名.内部类名 变量名 = new 外部类名().new 内部类名(); 需要注意的是，如果内部类被声明私有，外界将无法访问。 本章小结超市购物程序设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package cn.itcast.shop;public class Product &#123;//商品 private String proName;//商品名 public String getProName()&#123; return proName; &#125; public void setProName(String proName)&#123; this.proName = proName; &#125;&#125;package cn.itcast.shop;public class Market &#123;//超市 private String marketName;//超市名 private Product[] productArr;//超市的仓库，里面有若干商品 public String getMarketName()&#123; return marketName; &#125; public void setMarketName(String marketName)&#123; this.marketName = marketName; &#125; public Product[] getProductArr()&#123; return productArr; &#125; public void setProductArr(Product[] productArr)&#123; this.productArr = productArr; &#125; Product sell(String name)&#123;//卖货，指定商品名 //循环遍历仓库中每一个商品 for(int i=0;i&lt;productArr.length;i++)&#123; //如果商品名称和要买的商品一致 if(productArr[i].getProName()==name)&#123; return productArr[i];//将该商品返回 &#125; &#125; return null;//循环结束后没有找到商品，返回null代表没有买到 &#125;&#125;package cn.itcast.shop;public class Person &#123; //人 private String name; //人名 public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name=name; &#125; //购物，指定去那个超市，商品名 Product shopping(Market market,String name)&#123; //调用超市的卖货方法，指定商品名，把卖出的结果返回 return market.sell(name); &#125;&#125;package cn.itcast.shop;public class Shopping &#123; public static void main(String[] args)&#123; //创建商品对象，给名字赋值 Product p1 = new Product(); Product p2 = new Product(); Product p3 = new Product(); Product p4 = new Product(); Product p5 = new Product(); p1.setProName(&quot;电视机&quot;); p2.setProName(&quot;洗衣机&quot;); p3.setProName(&quot;豆浆机&quot;); p4.setProName(&quot;空调机&quot;); p5.setProName(&quot;吹风机&quot;); //创建超市对象，给超市名字赋值，给仓库赋值 Market m = new Market(); m.setMarketName(&quot;家乐福&quot;); m.setProductArr(new Product[]&#123;p1,p2,p3,p4,p5&#125;); //创建人对象，给名字赋值 Person p = new Person(); p.setName(&quot;小韩&quot;); //调用购物方法，指定超市和商品名，得到购物结果 Product result = p.shopping(m, &quot;豆浆机&quot;); //根据结果进行判断 if(result!=null)&#123; System.out.println(p.getName()+&quot;在&quot;+m.getMarketName()+&quot;买到了&quot;+result.getProName()); &#125;else&#123; System.out.println(p.getName()+&quot;白跑了一趟，在&quot;+m.getMarketName()+&quot;什么也没有买到了&quot;); &#125; &#125;&#125; 银行新用户现金业务办理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package cn.itcast.bank;public class Bank &#123; static String bankName;//定义静态变量银行名称 private String name; //储户姓名 private String password; //密码 private double balance;//账户余额 private double turnover;//交易额 //静态方法，打印出银行欢迎语句 static void welcome()&#123; System.out.println(&quot;欢迎来到&quot;+bankName+&quot;--------------&quot;); &#125; //构造方法 开户 public Bank(String name,String password,double turnover)&#123; //将变量赋值给成员变量 this.name=name; this.password=password; this.turnover=turnover; this.balance=turnover-10; System.out.println(name+&quot;开户成功，账户余额&quot;+balance); &#125; //存款 public void deposit(double turnover)&#123; balance = balance+turnover; System.out.println(name+&quot;您好,您的账户 已存入&quot;+turnover+&quot;元，当前余额&quot;+balance+&quot;元&quot;); &#125; //取款 public void withdrawal(String password,double turnover)&#123; //根据传入的变量与成员变量比对，判断密码是否正确 if(this.password!=password)&#123; System.out.println(&quot;输入密码错误&quot;); return; &#125; //判断余额是否充足 if(balance-turnover&gt;0)&#123; balance=balance-turnover; System.out.println(name+&quot;您好，您的账户 以取出&quot;+turnover+&quot;元，当前余额&quot;+balance+&quot;元&quot;); &#125;else&#123; System.out.println(&quot;对不起，账户余额不足！&quot;); &#125; &#125; //静态方法，打印出银行欢迎下次光临语句 static void welcomeNext()&#123; System.out.println(&quot;欢迎下次光临&quot;+bankName+&quot;-----------&quot;); &#125;&#125;package cn.itcast.bank;public class Trade &#123; public static void main(String[] args)&#123; //定义一家银行（给静态变量赋值，可以直接使用类名访问） Bank.bankName=&quot;招商银行&quot;; //调用静态方法，银行打印欢迎语句 Bank.welcome(); //通过构造方法进行开户操作 Bank bank = new Bank(&quot;小梦&quot;,&quot;654321&quot;,100.0); //进行存款操作 bank.deposit(500.00); //取款时密码错误，取款失败 bank.withdrawal(&quot;1234565&quot;, 200); //取款时余额不足时，取款失败 bank.withdrawal(&quot;654321&quot;, 1000.00); //取款时密码正确，余额充足，取款成功 bank.withdrawal(&quot;654321&quot;, 200.00); //调用静态方法，银行打印道别语句 Bank.welcomeNext(); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序入门-基本操作]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[微信小程序简介微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 编译工具简介为了帮助开发者简单和高效地开发和调试微信小程序，我们在原有的公众号网页调试工具的基础上，推出了全新的 微信开发者工具，集成了公众号网页调试和小程序调试两种开发模式。 编译工具使用步骤 入门hello world 制作一个小程序材料准备 写代码 上传 总结小程序其实就是根据网页设计的HTML和css进行一种修改。]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 new year flag]]></title>
    <url>%2F2019%2F02%2F02%2F2019-new-year-flag%2F</url>
    <content type="text"><![CDATA[完成一项以后 后面画一个对勾 独立开发一个微信小程序 成为大佬 学习轮滑 学会滑板 教会弟弟妹妹滑板、轮滑 学习一门主流框架 微信公共号开始一周一次 减肥三十斤 追一年princess 合伙开发一个校园app 学习一些新东西 得到一份好的实习机会 给社团以后的发展铺好路 一个月更新二篇博客（2019/2/2 21:26 未完待续 ）]]></content>
      <tags>
        <tag>2019 flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[two]]></title>
    <url>%2F2019%2F01%2F25%2Ftwo%2F</url>
    <content type="text"><![CDATA[海底月是天上月，眼前人是心上人。向来心是看客心，奈何人是剧中人。 –张爱玲《倾城之恋》 我希望有个如你一般的人 如山间清爽的风 如古城温暖的光 从清晨到夜晚 由山野到书房 只要最后是你 就好 –张嘉佳《从你的全世界路过》 我最讨厌说的就是本可以三个字，状况都发生了才说本可以有个屁用！ –肖海洋《一起同过窗》 所谓朋友，就是在看似一成不变中悄悄靠近，幡然醒悟之时，却已反常到无话不谈。 –毕十三《一起同过窗》 我们精心策划，按部就班，等待某一时刻的发生，也许它真的发生了，却和你想象的有点不一样。 –路桥川《一起同过窗》 我真的好讨厌你，讨厌你这么喜欢另一个女生，我讨厌你对我无视的态度，我讨厌你忘记我，我好讨厌你，真的好讨厌你。 –林洛雪《一起同过窗》 如果爱情不光是甜蜜，同样有伤痕，有痛苦，那我的毫无保留，到底值不值得。 –顾一心《一起同过窗》 其实你的内心，比其他人要执着许多，只是缺少果断，所以别的人会走的很快，而你会走的很长。 –叶吉平《一起同过窗》 “不舍”和“留恋”怎么会一样呢？况且你做到的是“不”和“舍”，而我想要的是“留”和“恋”。 –李殊词《一起同过窗》 但是，我虽然烂，我每次喜欢上一个女孩的时候，我都真心地觉得她是一个很可爱的姑娘。或者说，在我眼里，每个女孩子都有可爱的一面，我从来不觉得女孩子有任何的缺点。 –任逸帆《一起同过窗》 我曾以为黎明之后，太阳就会升起，就会有光。最近才知道，原来黑夜和黎明之前，还有一个时刻，叫破晓。破晓之后，新的一天才正式开始。 –钟白《一起同过窗》]]></content>
      <tags>
        <tag>优美句子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程基础]]></title>
    <url>%2F2019%2F01%2F25%2FJava%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java的基本语法Java代码的基本格式 Java中的程序代码可分为结构定义语句和功能执行语句，其中，结构定义语句用于声明一个类或者方法，功能执行语句用于实现具体的功能。每条功能执行语句的最后都必须用英文分号(;)结束。 Java语言严格区分大小写。 为了便于阅读，尽量使自己的代码整齐美观、层次清晰。 Java程序中一个太长的字符串不能分开在二行中书写。为了其他原因，可以使用（+）号将二个字符串链接起来。 Java中的注释 单行注释 int a; //定义一个整形变量 多行注释 12345678/* int a; //定义一个整形变量 public static void main(String[] args)&#123; printRectangle(4,3); printRectangle(2,3); printRectangle(6,10); &#125; */ 文档注释,文档注释是以“/*”开头，并在注释内容末尾以“/”结束。文档注释是对一段代码概括性的解释说明，可以使用Javadoc命令将文档注释提取出来生成帮助文档。 Java中的标识符在编程过程中，经常需要在程序中定义一些符号来标记一些名称，如包名、类名、方法名、参数名、变量名等，这些符号被称为标识符。标识符可以由字母、数字、下划线和美元符号（$）组成，但标识符不能以数字开头，不能是Java中的关键字。 为了增加代码可读性，初学者应该遵循以下规则。 包名所有字母一律小写。例如：cn.itcast.test 类名和接口名每个单词的首字母都要大写。例如：ArrayList 常量名所有字母都大写，单词之间用下划线链接。例如：DAY_OF_MONTH 变量名和方法名的第一个单词首字母小写，从第二个单词开始，每个单词首字母大写。例如：lineNumber 在程序中，应尽量使用有意义的英文单词来定义标识符，使得程序便于阅读。例如：password表示密码 Java中的关键字关键字是编程语言里事先定义好并赋予了特殊含义的单词。 Java所有关键字：abstract、continue、for、new、switch、assert、default、goto、package（用于包的声明）、synchronized、boolean、do、if、private、this、break、double、implements、protected、throw、byte、else、import（用于引入包）、public、throws、case、enum、instanceof、return、transient、catch、extends、int、short、try、char、final、interface、static、void、class（用于类的声明）、finally、long、strictfp、volatile、const、float、native、super、while。 所有的关键字都是小写的。 程序中的标识符不能不能以关键字命名。 const和goto是保留字关键字，虽然在Java中还没有任何意义，但在程序中不能用来作为自定义的标识符。 true、false和null不属于关键字，他们是一个单独标识类型，不能直接使用。 Java中的常量常量就是在程序中固定不变的值，是不能改变的数据。在Java中，常量包括整形常量、浮点数常量、布尔常量、字符常量等。 整形变量整形变量是整数类型的数据，有二进制、八进制、十进制、十六进制4中表示形式。 二进制：由数字0和1组成的数字序列。前面要以0b或0B开头，目的是为了和十进制进行区分，如0b01101100。 八进制：以0开头并且其后由0~7范围内（包括0和7）的整数组成的数字序列，如0342。 十进制：由数字0~9范围内（包括0和9）的整数组成的数字序列，如198。 十六进制：以0x或者0X开头并且其后由0~9、A~F（包括0和9、A和F，字母不区分大小写）组成的数字序列，如0x25AF。 注意：八进制必须以0开头，十六进制必须以0X或0x开头，整数以十进制表示时，开头第一位不能是0，0本身除外。 浮点数常量浮点数常量就是在数学中用到的小数，分为float单精度浮点数和double双精度浮点数二种类型。其中，单精度浮点数后面以F或f结尾，而双精度浮点数则以D或d结尾。当然，在使用浮点数时也可以在结尾处不加任何后缀，此时，虚拟机会默认为double双精度浮点数。浮点数常量还可以通过指数形式来表示。 2e3f 3.6d 0f 3.84d 5.022e+23f 字符常量字符常量用于表示一个字符，一个字符常量要用一对英文半角格式的单引号’’引起来，它可以是英文字母、数字、标点符号以及由转义序列来表示的特殊字符。 &#39;a&#39; &#39;1&#39; &#39;&amp;&#39; &#39;\r&#39; &#39;\u0000&#39; ‘\u0000’表示一个空白字符，即单引号之间没有任何字符。之所以能这样表示，是因为Java采用的是Unicode字符集，Unicode字符以\u开头，空白字符在Unicode码中对应的值为’\u0000’。 字符串常量字符串常量用于表示一串连续的字符，一个字符串常量要用一对英文半角格式的双引号(“”)引起来。 &quot;helloworld&quot; &quot;123&quot; &quot;welcome \n xxx&quot; &quot;&quot; 一个字符串可以包含一个字符或者多个字符，也可以不包含任何字符，即长度为零。 布尔常量布尔常量即布尔型的二个值true和false，该常量用于区分一个事物的真假。 null常量null常量只有一个值null，表示对象的引用为空。 Java中的变量变量的定义在程序运行期间，随时可能产生一些临时数据，应用程序会将这些数据保存在一些内存单元中，每个内存单元都用一个标识符来标识。这些内存单元被称为变量，定义的标识符就是变量名，内存单元中存储的数据就是变量的值。 变量的数据类型Java是一门强类型的编程语言，它对变量的数据类型有严格的限定。定义变量时必须声明变量的类型，在为变量赋值时必须赋予和变量同一类型的值，否则程序会报错。 在Java中，变量的数据类型分为二种，即基本数据类型和引用数据类型。Java中所有的数据类型如下图所示： 整数类型变量整数类型变量用来存储整数数值，即没有小数部分的值。在Java中，为了给不同大小范围内的整数合理分配储存空间，整数类型分为4种不同的类型:字节型(byte)、短整型(short)、整型(int)、长整型(long)。4种类型所占的存储空间的大小以及取值范围如下图所示。 在为一个long类型的变量赋值时，所赋值的后面要加上一个字母(L或者l) 浮点数类型变量浮点数类型变量用来储存小数数值。在Java中，浮点数类型分为二类：单精度浮点数(float)和双精度浮点数(double)。double类型比float类型更精确。具体如下图所示。 字符类型变量字符类型变量用于存储一个单一字符，每个char类型的字符变量都会占有2个字节。在给char类型的变量赋值时，需要用一对英文半角格式的单引号’’把字符括起来，也可以将char类型的变量赋值为0~65535范围内的整数，计算机会自动将这些整数转化为所对应的字符。 布尔类型变量布尔类型变量用来储存布尔值，在Java中用boolean表示，该类型的变量只有二个值，即true和false。具体如下所示12boolean flag=false; //声明一个boolean类型变量，初始值为falseflag = true; //改变flag变量的值为true 变量的类型转换在程序中，当把一种数据类型的值赋予给另一种数据类型的变量时，需要进行数据类型转换。根据转换方式的不同，数据类型转换可分为二种:自动类型转换和强制类型转换。 自动类型转换自动类型转换也叫隐式类型转换，指的是二种数据类型在转换的过程中不需要显示地进行声明。要实现自动类型转换，必须同时满足二个条件，第一个是二种数据类型彼此兼容，第二是目标的类型的取值范围大于源类型的取值范围。 整数类型之间可以实现转换，如byte类型的数据可以赋值给short、int、long类型的变量，short、char类型的数据可以赋值给int、long类型的变量，int类型的数据可以赋值给long类型的变量。 整数类型转换为float类型，如byte、char、short、int类型的数据可以赋值给float类型的变量。 其他类型转换为double类型，如byte、char、short、int、long、float类型的数据可以赋值给double类型的变量。 强制类型转换强制类型转换也称为显示类型转换，指的是二种数据类型之间的转换需要进行显示的声明。当二种类型彼此不兼容，或者目标类型取值范围小于源类型时，自动类型转换无法进行，这时就需要进行强制类型转换。 需要进行强制类型转换，具体格式如下 12目标类型 变量名 = (目标类型) 值;byte b = (byte) num; 在对变量进行强制类型转换时，会发生取值范围较大的数据类型向取值范围较小的数据类型的转换，会很容易造成数据精度的丢失。 变量的作用域变量需要先定义后使用，但并不意味着在变量定义之后的语句中一定可以使用该变量。变量需要在它的作用范围内才可以被使用，这个作用范围被称为变量的作用域。在程序中，变量一定会被定义在某一对大括号中，该大括号所包含的代码区域便是这个变量的作用域。具体如下图: Java中的运算符在程序中经常出现一些特殊符号，如+、-*、/、=、&gt;等，这些特殊符号称为运算符。运算符用于对数据进行算术运算、赋值和比较等操作。在Java中，运算符可分为算术运算符、赋值运算符、比较运算符、逻辑运算符等。 算术运算符在数学运算中最常见的就是加减乘除，被称为四则运算。Java中的算术运算符就是用来处理四则运算的符号，这是最简单、最常用的运算符。Java中的算术运算符及其用法。如下图所示： 在进行自增++和自减–的运算时，如果运算符++或–放在操作数的前面则是先进行自增或自减运算，在进行其他运算。反之，如果运算符放在操作数后面则先进行其他运算在进行自增或自减运算。 在进行除法运算时，当除数和被除数都为整数时，得到的结果也是一个整数。如果除法运算有小数参与，得到的结果会是一个小数。 在进行取模(%)运算时，运算结果的正负取决于被模数(%左边的数)的符号，与模数(%右边的数)的符号无关。 赋值运算符赋值运算符的作用就是将常量、变量或表达式的值赋给某一个变量。Java中的赋值运算符及其用法如下图所示： 1234int x,y,z;x=y=z=5; //为3个变量同时赋值int a=b=c=5; //这样写是错误的 在Java中可以通过一条赋值语句对多个变量进行赋值 图中除了“=”,其他的都是特殊的赋值运算符，以“+=”为例，x+=3就相当于x=x+3,首先会进行加法运算x+3,在将运算结果赋值给变量x。 比较运算符比较运算符用于对二个数值或变量进行比较，其结果是一个布尔值，即true或false。Java中的比较运算符及其用法。如下图所示： 注意，不能将比较运算符“==”误写成赋值运算符“=”。 逻辑运算符逻辑运算符用于对布尔型的数据进行操作，其结果仍是一个布尔数据。Java中的逻辑运算符及其用法。如下图所示： 逻辑运算符可以针对结果为布尔值的表达式进行运算。 运算符”&amp;”和”&amp;&amp;”都表示与操作，当且仅当运算符两边操作数都为true时，其结果才为true，否则结果为false。当运算符“&amp;”和“&amp;&amp;”的右边为表达式时，二者在使用上还有一定的区别。在使用“&amp;”进行运算时，无论左边为true或者false，右边的表达式都会进行运算。如果使用“&amp;&amp;”进行运算，当左边为false时，右边的表达式则不会进行运算，因此“&amp;&amp;”被称为短路与。 运算符“|”和“||”都表示或操作，当运算符两边的操作数任何一边的值为true时，其结果为true；当两边的值都为false时，其结果才为false。同与操作类似，“||”表示短路或，当运算符“||”的左边为true时，右边的表达式就不会进行运算。 运算符“^”表示异或操作，当运算符两边的布尔值相同时（都为true或都为false），其结果为false。当两边布尔值不相同时，其结果为true。 运算符的优先级在对一些比较复杂的表达式进行运算时，要明确表达式所有运算符参与运算的先后顺序，通常把这种顺序称作运算符的优先级。Java中的运算符的优先级具体如下图所示： 在编写程序时，尽量使用括号“()”来实现想要的运算顺序，以免产生歧义。 选择结构语句Java中有一种特殊的语句叫作选择语句，它需要对一些条件做出判断，从而决定执行哪一段代码。 if条件语句if语句if语句是指如果满足某种条件，就进行某种处理。123if(条件语句)&#123; 代码块&#125; 判断条件是一个布尔值，当判断条件为true时，{}中的执行语句才会执行。if语句的执行流程如下图所示： if…else语句if…else语句是指如果满足某种条件，就进行某种处理，否则就进行另一种处理。 1234567if(判断语句)&#123; 执行语句1 ...&#125;else&#123; 执行语句2 ...&#125; 判断条件是一个布尔值，当判断条件为true时，if后面{}中的执行语句1会执行。当判断条件为false时，else后面{}中的执行语句2会执行。if…else语句的执行流程图如下图所示： 在Java中有一种特殊的运算叫作三元运算，它和if-else语句类似， “判断条件?表达式1:表达式2” 三元运算会得到一个结果，通常用于对某个变量进行赋值，当判断条件成立时，运算结果为表达式1的值，否则结果为表达式2得值。 if…elseif…else语句if…else if…else语句用于多个条件进行判断，进行多种不同得处理。1234567891011if(判断条件1)&#123; 执行语句1&#125;else if(判断条件2)&#123; 执行语句2&#125;...else if(判断条件n)&#123; 执行语句n&#125;else&#123; 执行语句n+1&#125; switch条件语句switch条件语句也是一种很常见得选择语句，和if条件语句不同，它只能针对某个表达式的值做出判断，从而决定程序执行那一段代码。 123456789101112131415switch(表达式)&#123; case 目标值1: 执行语句1 break; case 目标值2: 执行语句2 break; ... case 目标值n: 执行语句n break; default: 执行语句n+1 break;&#125; 在上面的格式中，switch语句将表达式的值与每个case中的目标值进行匹配，如果找到了匹配的值，会执行对应case后的语句；如果没找到任何匹配的值，就会执行default后的语句。 循环结构语句在Java中有一种特殊的语句叫做循环语句，它可以实现将一段代码重复执行。 while循环语句while语句会反复地进行条件判断，只要条件成立，{}内的执行语句就会执行，直到条件不成立，while循环结束。1234while(循环条件)&#123; 执行语句 ...&#125; 在上面的语法结构中，{}中的执行语句被称作循环体，循环体是否执行取决于循环条件。当循环条件为true时，循环体就会执行。循环体执行完毕时会继续判断循环条件，如条件仍为true则会执行，直到循环条件为false时，整个循环过程才会结束。 do…while循环语句do…while循环语句和while循环语句类似。1234do&#123; 执行语句 ...&#125;while(循环条件); 在上面的语法结构中，关键字do后面{}中的执行语句是循环体。do…while循环语句将循环条件放在了循环体的后面。这就意味着，循环体会无条件执行一次，然后在根据循环条件来决定是否继续执行。do…while循环的执行流程如下图所示： for循环语句for循环语句是最常用的循环语句，一般用在循环次数已知的情况下。 1234for(初始化表达式;循环条件;操作表达式)&#123; 执行语句 ...&#125; 在上面的语法结构中，for关键字后面()中包括了3部分内容—初始化表达式、循环条件和操作表达式,它们之间用(;)分隔，{}中的执行语句为循环体。 1表示初始化表达式，2表示循环条件，3表示操作表达式，4表示循环体，通过序号来具体分析for循环的执行流程。具体如下： 12345678for(1;2;3)&#123; 4&#125;第一步，执行1第二步，执行2，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步第三步，执行4第四步，执行3，然后重复执行第二步第五步，退出循环 循环嵌套嵌套循环是指在一个循环语句的循环体中在定义一个循环语句的语法结构。while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以相互嵌套，其中最常见的是在for循环中嵌套for循环，格式如下。12345678for(初始化表达式;循环条件;操作表达式)&#123; ... for(初始化表达式;循环条件;操作表达式)&#123; 执行语句 ... &#125; ...&#125; 跳转语句（break，continue）跳转语句用于实现循环执行过程中程序流程的跳转。 break语句在switch条件语句和循环语句中都可以使用break语句。当它出现在switch条件语句中时；作用是终止某个case并跳出switch结构。当它出现在循环语句中，作用是跳出循环语句，执行后面的代码。 当break语句出现在嵌套循环中的内层循环，它只能跳出内层循环，如果想使用break语句跳出外层循环，则需要对外层循环添加标记。使用break itcast；语句跳出外层循环。 continue语句continue语句用在循环语句中，它的作用是终止本次循环，执行下一次循环，在循环嵌套语句中，continue语句后面也可以使用标记的方式结束本此外层循环，用法与break语句相似。 方法什么是方法方法就是一段可以重复调用的代码，有些书里也会把方法称为函数。在Java中，声明一个方法的具体语法格式如下： 12345修饰符 返回值类型 方法名 ([参数类型 参数1，参数类型 参数2，...])&#123; 执行语句 ... return 返回值;&#125; 修饰符:方法的修饰符比较多，有对访问权限进行限定的，有静态修饰符static，还有最终修饰符final等。 返回值类型:用于限定方法返回值的数据类型。 参数类型:用于限定调用方法时传入参数的数据类型。 参数名:是一个变量，用于接收调用方法时传入的数据。 return关键字:用于结束方法以及返回指定类型的值。 返回值:被return语句返回的值，该值会返回给调用者。 需要注意的是，方法中的“参数类型 参数1，参数类型 参数2”被称为参数列表，它用于描述方法在被调用时需要接收的参数。如果方法不需要接收任何参数，则参数列表为空，即()内不写任何内容。方法的返回值必须为方法的返回值类型，如果方法中没有返回值，返回值类型要声明为void，此时，方法中return语句可以省略。 方法的重载Java中允许在一个程序中定义多个名称相同的方法，但是参数的类型或个数必须不同，这就是方法的重载。 方法的重载与返回值类型无关，它需要满足二个条件，一是方法名相同，二是参数个数或参数类型不相同。 数组数组是指一组数据的集合，数组中的每个数据被称为元素。数组可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。 数组的定义在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式称作动态初始化。在初始化数组时还有一种方式叫作静态初始化，就是在定义数组的同时就为数组的每个元素赋值。数组的静态初始化有二种方式，具体如下： 121.类型[] 数组名 = new 类型[]&#123;元素,元素,.....&#125;;2.类型[] 数组名 = &#123;元素,元素,.....&#125;; 建议使用第二种方式 当数组被成功创建以后，数组中元素会被自动赋予一个默认值，根据元素类型的不同，默认初始化的值也是不一样的。具体如下图: 数组的常见操作数组遍历在操作数组时，经常需要依此访问数组中的每个元素，这种操作称为数组的遍历。 数组最值在操作数组时，经常需要获取数组元素的最值。 数组排序在操作数组时，经常需要对数组中的元素进行排序。 冒泡排序，不断地比较数组相邻的两个元素，较小者向上浮，较大者往下沉，整个过程和水中气泡上升的原理相似。 多维数组多维数组可以简单地理解为在数组中嵌套数组。 第一种方式: int[][] arr = new int[3][4]; 第二种方式: int[][] arr = new int[3][]; 第三种方式: 1int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4,5,6&#125;,&#123;7,8,9&#125;&#125; 总结情不知所起 一往情深 怎奈何 如花美眷 终不敌 似水流年 缘莫明以由 两厢缘孽 更那堪 拟仙娇娥 难留恋 风花雪月 商场库存清单程序设计12345678910111213141516171819202122232425262728293031323334353637383940//计算商城库存清单功能的实现代码package cn.itcast.chapter01;public class StoreList &#123; public static void main(String[] args)&#123; //苹果笔记本电脑 String macBrand = &quot;MacBookAir&quot;; double macSize = 13.3; double macPrice = 6988.88; String macConfig = &quot;i5处理器4GB内存128G固态硬盘&quot;; int macCount = 5; //联想Thinkpad笔记本电脑 String thinkpadBrand = &quot;ThinkpadT450&quot;; double thinkpadSize = 14.0; double thinkpadPrice = 5999.99; String thinkpadConfig = &quot;i5处理器4GB内存500G硬盘&quot;; int thinkpadCount = 10; //华硕ASUS笔记本电脑 String ASUSBrand = &quot;ASUS-FL5800&quot;; double ASUSSize = 15.6; double ASUSPrice = 4999.50; String ASUSConfig = &quot;i7处理器4GB内存500G固态硬盘&quot;; int ASUSCount = 18; //列表头部 System.out.println(&quot;----------------------------商城库存清单------------------------------&quot;); System.out.println(&quot;品牌型号 尺寸 价格 配置 &quot; + &quot; 库存数&quot;); //列表中部 System.out.println(macBrand+&quot; &quot;+macSize+&quot; &quot;+macPrice+&quot; &quot;+macConfig+&quot; &quot;+macCount); System.out.println(thinkpadBrand+&quot; &quot;+thinkpadSize+&quot; &quot;+thinkpadPrice+&quot; &quot;+thinkpadConfig+&quot; &quot;+thinkpadCount); System.out.println(ASUSBrand+&quot; &quot;+ASUSSize+&quot; &quot;+ASUSPrice+&quot; &quot;+ASUSConfig+&quot; &quot;+ASUSCount); //统计总库存数、库存金额 int totalCount = macCount + thinkpadCount + ASUSCount; double totalMoney = (macCount*macPrice)+(thinkpadCount*thinkpadPrice)+(ASUSCount*ASUSPrice); //列表底部 System.out.println(&quot;--------------------------------------------------------------------&quot;); System.out.println(&quot;总库存数:&quot;+totalCount); System.out.println(&quot;库存商品总金额:&quot;+totalMoney); &#125; &#125; 猜数字游戏12345678910111213141516171819202122232425262728293031package cn.itcast.chapter01;import java.util.Random;import java.util.Scanner;public class GuessNumber &#123; public static void main(String[] args)&#123; //1.通过Random类中的nextInt(int n)方法，生成一个0~9的随机数 int randomNumber =new Random().nextInt(10); System.out.println(&quot;随机数已生成!&quot;); //2.输入猜的数字 System.out.println(&quot;----请输入你猜的数字:----&quot;); Scanner sc = new Scanner(System.in); int enterNumber = sc.nextInt(); //3.通过while循环，进行猜数字对错判断 //猜对，跳出循环，游戏结束 while (enterNumber != randomNumber)&#123; //猜错了，根据结果，给出提示，接着猜数字，游戏继续 if(enterNumber &gt; randomNumber)&#123; //如果猜大了，打印sorry，您猜大了！继续下一次循环 System.out.println(&quot;sorry 您猜大了！&quot;); &#125;else&#123; //如果猜小了，打印sorry，您猜小了！继续下一次循环 System.out.println(&quot;sorry 您猜小了！&quot;); &#125; //输入猜的数字 System.out.println(&quot;----请输入你猜的数字:----&quot;); enterNumber = sc.nextInt(); &#125; System.out.println(&quot;您猜对了！&quot;); &#125;&#125; 随机点名器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package cn.itcast.chapter01;import java.util.Random;import java.util.Scanner;public class CallName &#123; /** * 1.储存全班同学姓名 * 创建一个存储多个同学姓名的容器（数组） * 键盘输入每个同学的姓名，储存到容器中（数组） * @param students */ public static void addStudentName(String[] students)&#123; //键盘输入多个同学姓名储存到容器中 Scanner sc = new Scanner(System.in); for(int i=0;i&lt;students.length;i++)&#123; System.out.println(&quot;储存第&quot;+(i+1)+&quot;个名字：&quot;); //接收控制台录入的姓名字符串 students[i]=sc.next(); &#125; &#125; /** * 2.总览全班同学姓名 * */ public static void printStudentName(String[] students)&#123; //遍历数组，得到每个同学的姓名 for(int i=0;i&lt;students.length;i++)&#123; String name = students[i]; //打印同学姓名 System.out.println(&quot;第&quot;+(i+1)+&quot;个学生姓名：&quot;+name); &#125; &#125; /* * 3.随机点名其中一人 */ public static String randomStudentName(String[] students)&#123; //根据数组长度，获取随机索引 int index = new Random().nextInt(students.length); //通过随机索引从数组中获取姓名 String name = students[index]; //返回随机点到的姓名 return name; &#125; public static void main(String[] arg)&#123; System.out.println(&quot;------------随机点名器------------&quot;); String[] students = new String[3]; /* * 1.储存全班同学姓名 */ addStudentName(students); /* * 2.总览全班同学姓名 */ printStudentName(students); /* * 3.随机点名其中一人 */ String randomName=randomStudentName(students); System.out.println(&quot;被点到名的同学是：&quot;+randomName); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发入门问题及解决方案]]></title>
    <url>%2F2019%2F01%2F22%2FJava%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[JDK的安装错误及解决方案一开始把JDK安装到C盘，在C盘的安装目录下bin目录下编写第一个hello world程序的时候出现以下错误： 文件不能正常保存，需要提供管理员身份。 找不到类，需要创建的类和文件名保持一致 后缀名错误，需要把后缀名显示出来 进行编译是出错 解决方案:在C盘编写代码的时候，需要提供管理员身份，而且有些功能不能实现，所以建议把JDK安装到D盘。 （PS：不过我在安装开发工具的时候有把JDK安装到了C盘，个人感觉安装在那个盘都可以，只不过在C盘操作命令的时候比较麻烦） 系统环境变量的设置按照教材中的做法认真一点，应该不会出错。也可以自己百度一下看一下教程，大致上都是一样的。 eclipse安装错误及解决方案进入官网进行下载eclipse工具时，出现以下错误： 下载出错 安装出错 解决方案:在官网下载时需要下载的是压缩包而不是exe文件，因为网上大部分的安装教程都是将的压缩包的安装方式（ps:自己也不会其他的安装方式）安装是注意自己的安装包是32位还是64位，因为要和自己一开始安装的jdk进行版本的匹配，不同的可能导致安装出错。自己下载二个版本的eclipse压缩包就行了，一个不行换另一个安装就行了。嘻嘻。 总结错误永远都是有的，不多趟点雷，怎么会长知识呢。吃一垫，长一智。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发入门]]></title>
    <url>%2F2019%2F01%2F19%2FJava%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Java概述java是一门程序设计语言 什么是Java javaSE（标准版）开发普通桌面和商务应用程序 javaEE（企业版）开发企业级应用程序 javaME（小型版）开发电子消费产品和嵌入式设备 Java语言特点 简单性 面向对象性 安全性 跨平台性（ps:一段程序可以在Windows上运行，也可以在Linux上运行） 支持多线程 JDK的使用什么是JDKSUN公司提供的一套java开发环境 Java编辑器 Java运行工具 Java文档生成工具 Java打包工具 安装JDK 百度一下（ps:尽量不要安装在C盘） 第一个Java程序编写Java源文件在JDK安装目录的bin目录下新建文本文档，重命名为HelloWorld.java。然后用记事本打开编写一段Java代码，如下所示： 12345678910class HelloWorld&#123; public stacic void mian(String[] args)&#123; System.out.println(&quot;这是第一个Java程序&quot;); &#125;&#125; 打开命令行窗口快捷键win+r,在运行窗口中输入cmd 进入JDK安装目录的bin目录使用cmd命令cd进入安装JDK目录下的bin目录 编译Java源文件使用javac命令对源文件HelloWorld.java进行编译,会在当前目录下生成HelloWorld.class字节码文件。 javac HelloWorld.java Ps：注意类名和文件名保持一致 运行Java程序使用命令java运行文件 java HelloWorld.java 运行时只要输入java HelloWorld就行 系统环境变量在计算书操作系统中可以定义一系列变量，这些变量可提供操作系统上所有应用程序使用，被称为系统环境变量。 path环境变量path环境变量是系统变量的一种，它用于保存一系列的路径，每个路径之间以分号分隔。当在命令行窗口运行一个可执行文件时，操作系统首先会在当前目录下查找该文件是否存在，如果不存在，会继续在path环境变量中定义的路径下寻找这个文件，如果仍未找到，系统会报错。 classpath环境变量classpath环境变量也用于保存一系列路径，它和path环境变量的查看与配置的方式完全相同。当Java虚拟机需要运行一个类时，会在classpath环境变量中所定义的路径下寻找所需的class文件和类包。 环境变量的设置自行百度 Java的运行机制Java程序运行时，必须经过编译和运行二个步骤。首先将后缀名为.java的源文件进行编译，生成后缀名为.class的字节码文件。然后，Java虚拟机将字节码文件进行解释执行，并将结果显示出来。 java程序是由虚拟机负责 开发工具在实际项目开发过程中，由于使用笔记本编写代码速度慢，且不容易排错，所以程序员很少用它来编写代码。为了提高程序的开发效率，大部分软件开发人员都是使用集成开发工具（IDE）来进行程序开发。 Eclipse概述eclipse是由蓝色巨人开发的一款功能完整且成熟的IDE集成开发环境，它是一个开源的、基于Java的可扩展开发平台，目前最流行的Java语言开发工具之一。 Eclipse的安装与启动 安装eclipse开发工具 启动eclipse开发工具 eclipse工作台 eclipse透视图 Eclipse进行程序开发 创建Java项目 在项目下创建包 创建Java类 编写程序代码 运行程序 总结不要好高骛远]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[one]]></title>
    <url>%2F2019%2F01%2F18%2Fone%2F</url>
    <content type="text"><![CDATA[佛家说，人有七苦，生、老、病、死、怨憎会、爱离别、求不得，离合既循环，忧喜迭相攻，佛是想说，众生本该洒脱而淡然地接受一切的阴晴圆缺，可惜，我们只是普通人，不是佛。 《一起同过窗》]]></content>
      <tags>
        <tag>优美句子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F16%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>参考文献</tag>
      </tags>
  </entry>
</search>
